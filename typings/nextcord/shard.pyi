"""
This type stub file was generated by pyright.
"""

import asyncio
import aiohttp
from typing import Callable, Dict, List, Optional, TYPE_CHECKING, Tuple
from .client import Client
from .enums import Status
from .flags import Intents, MemberCacheFlags
from .gateway import *
from .gateway import DiscordWebSocket
from .state import AutoShardedConnectionState
from typing_extensions import Self
from .activity import BaseActivity
from .mentions import AllowedMentions

if TYPE_CHECKING:
    ...
__all__ = ("AutoShardedClient", "ShardInfo")
_log = ...
class EventType:
    close = ...
    reconnect = ...
    resume = ...
    identify = ...
    terminate = ...
    clean_close = ...


class EventItem:
    __slots__ = ...
    def __init__(self, etype: int, shard: Optional[Shard], error: Optional[Exception]) -> None:
        ...
    
    def __lt__(self, other: Self) -> bool:
        ...
    
    def __eq__(self, other: Self) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class Shard:
    def __init__(self, ws: DiscordWebSocket, client: AutoShardedClient, queue_put: Callable[[EventItem], None]) -> None:
        ...
    
    @property
    def id(self) -> int:
        ...
    
    def launch(self) -> None:
        ...
    
    async def close(self) -> None:
        ...
    
    async def disconnect(self) -> None:
        ...
    
    async def worker(self) -> None:
        ...
    
    async def reidentify(self, exc: ReconnectWebSocket) -> None:
        ...
    
    async def reconnect(self) -> None:
        ...
    


class ShardInfo:
    """A class that gives information and control over a specific shard.

    You can retrieve this object via :meth:`AutoShardedClient.get_shard`
    or :attr:`AutoShardedClient.shards`.

    .. versionadded:: 1.4

    Attributes
    ----------
    id: :class:`int`
        The shard ID for this shard.
    shard_count: Optional[:class:`int`]
        The shard count for this cluster. If this is ``None`` then the bot has not started yet.
    """
    __slots__ = ...
    def __init__(self, parent: Shard, shard_count: Optional[int]) -> None:
        ...
    
    def is_closed(self) -> bool:
        """:class:`bool`: Whether the shard connection is currently closed."""
        ...
    
    async def disconnect(self) -> None:
        """|coro|

        Disconnects a shard. When this is called, the shard connection will no
        longer be open.

        If the shard is already disconnected this does nothing.
        """
        ...
    
    async def reconnect(self) -> None:
        """|coro|

        Disconnects and then connects the shard again.
        """
        ...
    
    async def connect(self) -> None:
        """|coro|

        Connects a shard. If the shard is already connected this does nothing.
        """
        ...
    
    @property
    def latency(self) -> float:
        """:class:`float`: Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds for this shard."""
        ...
    
    def is_ws_ratelimited(self) -> bool:
        """:class:`bool`: Whether the websocket is currently rate limited.

        This can be useful to know when deciding whether you should query members
        using HTTP or via the gateway.

        .. versionadded:: 1.6
        """
        ...
    


class AutoShardedClient(Client):
    """A client similar to :class:`Client` except it handles the complications
    of sharding for the user into a more manageable and transparent single
    process bot.

    When using this client, you will be able to use it as-if it was a regular
    :class:`Client` with a single shard when implementation wise internally it
    is split up into multiple shards. This allows you to not have to deal with
    IPC or other complicated infrastructure.

    It is recommended to use this client only if you have surpassed at least
    1000 guilds.

    If no :attr:`.shard_count` is provided, then the library will use the
    Bot Gateway endpoint call to figure out how many shards to use.

    If a ``shard_ids`` parameter is given, then those shard IDs will be used
    to launch the internal shards. Note that :attr:`.shard_count` must be provided
    if this is used. By default, when omitted, the client will launch shards from
    0 to ``shard_count - 1``.

    Attributes
    ----------
    shard_ids: Optional[List[:class:`int`]]
        An optional list of shard_ids to launch the shards with.
    """
    if TYPE_CHECKING:
        _connection: AutoShardedConnectionState
        ...
    def __init__(self, *, shard_ids: Optional[list[int]] = ..., max_messages: Optional[int] = ..., connector: Optional[aiohttp.BaseConnector] = ..., proxy: Optional[str] = ..., proxy_auth: Optional[aiohttp.BasicAuth] = ..., shard_id: Optional[int] = ..., shard_count: Optional[int] = ..., application_id: Optional[int] = ..., intents: Intents = ..., member_cache_flags: MemberCacheFlags = ..., chunk_guilds_at_startup: bool = ..., status: Optional[Status] = ..., activity: Optional[BaseActivity] = ..., allowed_mentions: Optional[AllowedMentions] = ..., heartbeat_timeout: float = ..., guild_ready_timeout: float = ..., assume_unsync_clock: bool = ..., enable_debug_events: bool = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., lazy_load_commands: bool = ..., rollout_associate_known: bool = ..., rollout_delete_unknown: bool = ..., rollout_register_new: bool = ..., rollout_update_known: bool = ..., rollout_all_guilds: bool = ..., default_guild_ids: Optional[List[int]] = ...) -> None:
        ...
    
    @property
    def latency(self) -> float:
        """:class:`float`: Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds.

        This operates similarly to :meth:`Client.latency` except it uses the average
        latency of every shard's latency. To get a list of shard latency, check the
        :attr:`latencies` property. Returns ``nan`` if there are no shards ready.
        """
        ...
    
    @property
    def latencies(self) -> List[Tuple[int, float]]:
        """List[Tuple[:class:`int`, :class:`float`]]: A list of latencies between a HEARTBEAT and a HEARTBEAT_ACK in seconds.

        This returns a list of tuples with elements ``(shard_id, latency)``.
        """
        ...
    
    def get_shard(self, shard_id: int) -> Optional[ShardInfo]:
        """Optional[:class:`ShardInfo`]: Gets the shard information at a given shard ID or ``None`` if not found."""
        ...
    
    @property
    def shards(self) -> Dict[int, ShardInfo]:
        """Mapping[int, :class:`ShardInfo`]: Returns a mapping of shard IDs to their respective info object."""
        ...
    
    async def launch_shard(self, gateway: str, shard_id: int, *, initial: bool = ...) -> None:
        ...
    
    async def launch_shards(self) -> None:
        ...
    
    async def connect(self, *, reconnect: bool = ...) -> None:
        ...
    
    async def close(self) -> None:
        """|coro|

        Closes the connection to Discord.
        """
        ...
    
    async def change_presence(self, *, activity: Optional[BaseActivity] = ..., status: Optional[Status] = ..., shard_id: Optional[int] = ...) -> None:
        """|coro|

        Changes the client's presence.

        Example: ::

            game = nextcord.Game("with the API")
            await client.change_presence(status=nextcord.Status.idle, activity=game)

        .. versionchanged:: 2.0
            Removed the ``afk`` keyword-only parameter.

        Parameters
        ----------
        activity: Optional[:class:`BaseActivity`]
            The activity being done. ``None`` if no currently active activity is done.
        status: Optional[:class:`Status`]
            Indicates what status to change to. If ``None``, then
            :attr:`Status.online` is used.
        shard_id: Optional[:class:`int`]
            The shard_id to change the presence to. If not specified
            or ``None``, then it will change the presence of every
            shard the bot can see.

        Raises
        ------
        InvalidArgument
            If the ``activity`` parameter is not of proper type.
        """
        ...
    
    def is_ws_ratelimited(self) -> bool:
        """:class:`bool`: Whether the websocket is currently rate limited.

        This can be useful to know when deciding whether you should query members
        using HTTP or via the gateway.

        This implementation checks if any of the shards are rate limited.
        For more granular control, consider :meth:`ShardInfo.is_ws_ratelimited`.

        .. versionadded:: 1.6
        """
        ...
    


