"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, List, Optional, Protocol, Sequence, TYPE_CHECKING, TypeVar, Union, overload, runtime_checkable
from .context_managers import Typing
from .enums import ChannelType, InviteTarget
from .file import File
from .flags import ChannelFlags, MessageFlags
from .invite import Invite
from .iterators import HistoryIterator
from .mentions import AllowedMentions
from .permissions import PermissionOverwrite, Permissions
from .role import Role
from .sticker import GuildSticker, StickerItem
from .voice_client import VoiceProtocol
from datetime import datetime
from typing_extensions import Self
from .asset import Asset
from .channel import CategoryChannel, DMChannel, GroupChannel, PartialMessageable, TextChannel
from .client import Client
from .embeds import Embed
from .guild import Guild
from .member import Member
from .message import Message, MessageReference, PartialMessage
from .state import ConnectionState
from .threads import Thread
from .types.channel import GuildChannel as GuildChannelPayload, PermissionOverwrite as PermissionOverwritePayload
from .ui.view import View
from .user import ClientUser

__all__ = ("Snowflake", "User", "PrivateChannel", "GuildChannel", "Messageable", "Connectable")
T = TypeVar("T", bound=VoiceProtocol)
if TYPE_CHECKING:
    PartialMessageableChannel = Union[TextChannel, Thread, DMChannel, PartialMessageable]
    MessageableChannel = Union[PartialMessageableChannel, GroupChannel]
    SnowflakeTime = Union["Snowflake", datetime]
@runtime_checkable
class Snowflake(Protocol):
    """An ABC that details the common operations on a Discord model.

    Almost all :ref:`Discord models <discord_api_models>` meet this
    abstract base class.

    If you want to create a snowflake on your own, consider using
    :class:`.Object`.

    Attributes
    ----------
    id: :class:`int`
        The model's unique ID.
    """
    __slots__ = ...
    id: int


@runtime_checkable
class User(Snowflake, Protocol):
    """An ABC that details the common operations on a Discord user.

    The following implement this ABC:

    - :class:`~nextcord.User`
    - :class:`~nextcord.ClientUser`
    - :class:`~nextcord.Member`

    This ABC must also implement :class:`~nextcord.abc.Snowflake`.

    Attributes
    ----------
    name: :class:`str`
        The user's username.
    discriminator: :class:`str`
        The user's discriminator.
    avatar: :class:`~nextcord.Asset`
        The avatar asset the user has.
    bot: :class:`bool`
        If the user is a bot account.
    """
    __slots__ = ...
    name: str
    discriminator: str
    avatar: Asset
    bot: bool
    @property
    def display_name(self) -> str:
        """:class:`str`: Returns the user's display name."""
        ...
    
    @property
    def mention(self) -> str:
        """:class:`str`: Returns a string that allows you to mention the given user."""
        ...
    


@runtime_checkable
class PrivateChannel(Snowflake, Protocol):
    """An ABC that details the common operations on a private Discord channel.

    The following implement this ABC:

    - :class:`~nextcord.DMChannel`
    - :class:`~nextcord.GroupChannel`

    This ABC must also implement :class:`~nextcord.abc.Snowflake`.

    Attributes
    ----------
    me: :class:`~nextcord.ClientUser`
        The user presenting yourself.
    """
    __slots__ = ...
    me: ClientUser
    @property
    def jump_url(self) -> str:
        """:class:`str`: Returns a URL that allows the client to jump to the referenced messageable.

        .. versionadded:: 2.0
        """
        ...
    


class _Overwrites:
    __slots__ = ...
    ROLE = ...
    MEMBER = ...
    def __init__(self, data: PermissionOverwritePayload) -> None:
        ...
    
    def is_role(self) -> bool:
        ...
    
    def is_member(self) -> bool:
        ...
    


GCH = TypeVar("GCH", bound="GuildChannel")
class GuildChannel:
    """An ABC that details the common operations on a Discord guild channel.

    The following implement this ABC:

    - :class:`~nextcord.TextChannel`
    - :class:`~nextcord.VoiceChannel`
    - :class:`~nextcord.CategoryChannel`
    - :class:`~nextcord.StageChannel`
    - :class:`~nextcord.ForumChannel`

    This ABC must also implement :class:`~nextcord.abc.Snowflake`.

    Attributes
    ----------
    name: :class:`str`
        The channel name.
    guild: :class:`~nextcord.Guild`
        The guild the channel belongs to.
    position: :class:`int`
        The position in the channel list. This is a number that starts at 0.
        e.g. the top channel is position 0.
    """
    __slots__ = ...
    id: int
    name: str
    guild: Guild
    type: ChannelType
    position: int
    category_id: Optional[int]
    flags: ChannelFlags
    _state: ConnectionState
    _overwrites: List[_Overwrites]
    if TYPE_CHECKING:
        def __init__(self, *, state: ConnectionState, guild: Guild, data: GuildChannelPayload) -> None:
            ...
        
    def __str__(self) -> str:
        ...
    
    @property
    def changed_roles(self) -> List[Role]:
        """List[:class:`~nextcord.Role`]: Returns a list of roles that have been overridden from
        their default values in the :attr:`~nextcord.Guild.roles` attribute."""
        ...
    
    @property
    def mention(self) -> str:
        """:class:`str`: The string that allows you to mention the channel."""
        ...
    
    @property
    def created_at(self) -> datetime:
        """:class:`datetime.datetime`: Returns the channel's creation time in UTC."""
        ...
    
    def overwrites_for(self, obj: Union[Role, User]) -> PermissionOverwrite:
        """Returns the channel-specific overwrites for a member or a role.

        Parameters
        ----------
        obj: Union[:class:`~nextcord.Role`, :class:`~nextcord.abc.User`]
            The role or user denoting
            whose overwrite to get.

        Returns
        -------
        :class:`~nextcord.PermissionOverwrite`
            The permission overwrites for this object.
        """
        ...
    
    @property
    def overwrites(self) -> Dict[Union[Role, Member], PermissionOverwrite]:
        """Returns all of the channel's overwrites.

        This is returned as a dictionary where the key contains the target which
        can be either a :class:`~nextcord.Role` or a :class:`~nextcord.Member` and the value is the
        overwrite as a :class:`~nextcord.PermissionOverwrite`.

        Returns
        -------
        Dict[Union[:class:`~nextcord.Role`, :class:`~nextcord.Member`], :class:`~nextcord.PermissionOverwrite`]
            The channel's permission overwrites.
        """
        ...
    
    @property
    def category(self) -> Optional[CategoryChannel]:
        """Optional[:class:`~nextcord.CategoryChannel`]: The category this channel belongs to.

        If there is no category then this is ``None``.
        """
        ...
    
    @property
    def permissions_synced(self) -> bool:
        """:class:`bool`: Whether or not the permissions for this channel are synced with the
        category it belongs to.

        If there is no category then this is ``False``.

        .. versionadded:: 1.3
        """
        ...
    
    @property
    def jump_url(self) -> str:
        """:class:`str`: Returns a URL that allows the client to jump to this channel.

        .. versionadded:: 2.0
        """
        ...
    
    def permissions_for(self, obj: Union[Member, Role], /) -> Permissions:
        """Handles permission resolution for the :class:`~nextcord.Member`
        or :class:`~nextcord.Role`.

        This function takes into consideration the following cases:

        - Guild owner
        - Guild roles
        - Channel overrides
        - Member overrides
        - Timed-out members

        If a :class:`~nextcord.Role` is passed, then it checks the permissions
        someone with that role would have, which is essentially:

        - The default role permissions
        - The permissions of the role used as a parameter
        - The default role permission overwrites
        - The permission overwrites of the role used as a parameter

        .. versionchanged:: 2.3
            Only ``view_channel`` and ``read_message_history`` can be returned for timed-out members

        .. versionchanged:: 2.0
            The object passed in can now be a role object.

        Parameters
        ----------
        obj: Union[:class:`~nextcord.Member`, :class:`~nextcord.Role`]
            The object to resolve permissions for. This could be either
            a member or a role. If it's a role then member overwrites
            are not computed.

        Returns
        -------
        :class:`~nextcord.Permissions`
            The resolved permissions for the member or role.
        """
        ...
    
    async def delete(self, *, reason: Optional[str] = ...) -> None:
        """|coro|

        Deletes the channel.

        You must have :attr:`~nextcord.Permissions.manage_channels` permission to use this.

        Parameters
        ----------
        reason: Optional[:class:`str`]
            The reason for deleting this channel.
            Shows up on the audit log.

        Raises
        ------
        ~nextcord.Forbidden
            You do not have proper permissions to delete the channel.
        ~nextcord.NotFound
            The channel was not found or was already deleted.
        ~nextcord.HTTPException
            Deleting the channel failed.
        """
        ...
    
    @overload
    async def set_permissions(self, target: Union[Member, Role], *, overwrite: Optional[PermissionOverwrite] = ..., reason: Optional[str] = ...) -> None:
        ...
    
    @overload
    async def set_permissions(self, target: Union[Member, Role], *, reason: Optional[str] = ..., **permissions: bool) -> None:
        ...
    
    async def set_permissions(self, target: Union[Member, Role], *, reason: Optional[str] = ..., **kwargs: Any): # -> None:
        r"""|coro|

        Sets the channel specific permission overwrites for a target in the
        channel.

        The ``target`` parameter should either be a :class:`~nextcord.Member` or a
        :class:`~nextcord.Role` that belongs to guild.

        The ``overwrite`` parameter, if given, must either be ``None`` or
        :class:`~nextcord.PermissionOverwrite`. For convenience, you can pass in
        keyword arguments denoting :class:`~nextcord.Permissions` attributes. If this is
        done, then you cannot mix the keyword arguments with the ``overwrite``
        parameter.

        If the ``overwrite`` parameter is ``None``, then the permission
        overwrites are deleted.

        You must have the :attr:`~nextcord.Permissions.manage_roles` permission to use this.

        .. note::

            This method *replaces* the old overwrites with the ones given.

        Examples
        --------

        Setting allow and deny: ::

            await message.channel.set_permissions(message.author, read_messages=True,
                                                                  send_messages=False)

        Deleting overwrites ::

            await channel.set_permissions(member, overwrite=None)

        Using :class:`~nextcord.PermissionOverwrite` ::

            overwrite = nextcord.PermissionOverwrite()
            overwrite.send_messages = False
            overwrite.read_messages = True
            await channel.set_permissions(member, overwrite=overwrite)

        Parameters
        ----------
        target: Union[:class:`~nextcord.Member`, :class:`~nextcord.Role`]
            The member or role to overwrite permissions for.
        overwrite: Optional[:class:`~nextcord.PermissionOverwrite`]
            The permissions to allow and deny to the target, or ``None`` to
            delete the overwrite.
        \*\*permissions
            A keyword argument list of permissions to set for ease of use.
            Cannot be mixed with ``overwrite``.
        reason: Optional[:class:`str`]
            The reason for doing this action. Shows up on the audit log.

        Raises
        ------
        ~nextcord.Forbidden
            You do not have permissions to edit channel specific permissions.
        ~nextcord.HTTPException
            Editing channel specific permissions failed.
        ~nextcord.NotFound
            The role or member being edited is not part of the guild.
        ~nextcord.InvalidArgument
            The overwrite parameter invalid or the target type was not
            :class:`~nextcord.Role` or :class:`~nextcord.Member`.
        """
        ...
    
    async def clone(self, *, name: Optional[str] = ..., reason: Optional[str] = ...) -> Self:
        """|coro|

        Clones this channel. This creates a channel with the same properties
        as this channel.

        You must have the :attr:`~nextcord.Permissions.manage_channels` permission to
        do this.

        .. versionadded:: 1.1

        Parameters
        ----------
        name: Optional[:class:`str`]
            The name of the new channel. If not provided, defaults to this
            channel name.
        reason: Optional[:class:`str`]
            The reason for cloning this channel. Shows up on the audit log.

        Raises
        ------
        ~nextcord.Forbidden
            You do not have the proper permissions to create this channel.
        ~nextcord.HTTPException
            Creating the channel failed.

        Returns
        -------
        :class:`.abc.GuildChannel`
            The channel that was created.
        """
        ...
    
    @overload
    async def move(self, *, beginning: bool, offset: int = ..., category: Optional[Snowflake] = ..., sync_permissions: bool = ..., reason: Optional[str] = ...) -> None:
        ...
    
    @overload
    async def move(self, *, end: bool, offset: int = ..., category: Optional[Snowflake] = ..., sync_permissions: bool = ..., reason: Optional[str] = ...) -> None:
        ...
    
    @overload
    async def move(self, *, before: Snowflake, offset: int = ..., category: Optional[Snowflake] = ..., sync_permissions: bool = ..., reason: Optional[str] = ...) -> None:
        ...
    
    @overload
    async def move(self, *, after: Snowflake, offset: int = ..., category: Optional[Snowflake] = ..., sync_permissions: bool = ..., reason: Optional[str] = ...) -> None:
        ...
    
    async def move(self, *, beginning: Optional[bool] = ..., end: Optional[bool] = ..., before: Optional[Snowflake] = ..., after: Optional[Snowflake] = ..., offset: int = ..., category: Optional[Snowflake] = ..., sync_permissions: bool = ..., reason: Optional[str] = ...) -> None:
        """|coro|

        A rich interface to help move a channel relative to other channels.

        If exact position movement is required, ``edit`` should be used instead.

        You must have the :attr:`~nextcord.Permissions.manage_channels` permission to
        do this.

        .. note::

            Voice channels will always be sorted below text channels.
            This is a Discord limitation.

        .. versionadded:: 1.7

        .. versionchanged:: 2.4

            ``beginning``, ``end``, ``before``, ``after`` and ``reason`` now accept ``None``.

        Parameters
        ----------
        beginning: Optional[:class:`bool`]
            Whether to move the channel to the beginning of the
            channel list (or category if given).
            This is mutually exclusive with ``end``, ``before``, and ``after``.
        end: Optional[:class:`bool`]
            Whether to move the channel to the end of the
            channel list (or category if given).
            This is mutually exclusive with ``beginning``, ``before``, and ``after``.
        before: Optional[:class:`~nextcord.abc.Snowflake`]
            The channel that should be before our current channel.
            This is mutually exclusive with ``beginning``, ``end``, and ``after``.
        after: Optional[:class:`~nextcord.abc.Snowflake`]
            The channel that should be after our current channel.
            This is mutually exclusive with ``beginning``, ``end``, and ``before``.
        offset: :class:`int`
            The number of channels to offset the move by. For example,
            an offset of ``2`` with ``beginning=True`` would move
            it 2 after the beginning. A positive number moves it below
            while a negative number moves it above. Note that this
            number is relative and computed after the ``beginning``,
            ``end``, ``before``, and ``after`` parameters.
        category: Optional[:class:`~nextcord.abc.Snowflake`]
            The category to move this channel under.
            If ``None`` is given then it moves it out of the category.
            This parameter is ignored if moving a category channel.
        sync_permissions: :class:`bool`
            Whether to sync the permissions with the category (if given).
        reason: Optional[:class:`str`]
            The reason for the move.

        Raises
        ------
        InvalidArgument
            An invalid position was given or a bad mix of arguments were passed.
        Forbidden
            You do not have permissions to move the channel.
        HTTPException
            Moving the channel failed.
        """
        ...
    
    async def create_invite(self, *, reason: Optional[str] = ..., max_age: int = ..., max_uses: int = ..., temporary: bool = ..., unique: bool = ..., target_type: Optional[InviteTarget] = ..., target_user: Optional[User] = ..., target_application_id: Optional[int] = ...) -> Invite:
        """|coro|

        Creates an instant invite from a text or voice channel.

        You must have the :attr:`~nextcord.Permissions.create_instant_invite` permission to
        do this.

        Parameters
        ----------
        max_age: :class:`int`
            How long the invite should last in seconds. If it's 0 then the invite
            doesn't expire. Defaults to ``0``.
        max_uses: :class:`int`
            How many uses the invite could be used for. If it's 0 then there
            are unlimited uses. Defaults to ``0``.
        temporary: :class:`bool`
            Denotes that the invite grants temporary membership
            (i.e. they get kicked after they disconnect). Defaults to ``False``.
        unique: :class:`bool`
            Indicates if a unique invite URL should be created. Defaults to True.
            If this is set to ``False`` then it will return a previously created
            invite.
        reason: Optional[:class:`str`]
            The reason for creating this invite. Shows up on the audit log.
        target_type: Optional[:class:`.InviteTarget`]
            The type of target for the voice channel invite, if any.

            .. versionadded:: 2.0

        target_user: Optional[:class:`User`]
            The user whose stream to display for this invite, required if ``target_type``
            is :attr:`.InviteTarget.stream`. The user must be streaming in the channel.

            .. versionadded:: 2.0

        target_application_id:: Optional[:class:`int`]
            The id of the embedded application for the invite, required if ``target_type``
            is :attr:`.InviteTarget.embedded_application`.

            .. versionadded:: 2.0

        Raises
        ------
        ~nextcord.HTTPException
            Invite creation failed.

        ~nextcord.NotFound
            The channel that was passed is a category or an invalid channel.

        Returns
        -------
        :class:`~nextcord.Invite`
            The invite that was created.
        """
        ...
    
    async def invites(self) -> List[Invite]:
        """|coro|

        Returns a list of all active instant invites from this channel.

        You must have :attr:`~nextcord.Permissions.manage_channels` to get this information.

        Raises
        ------
        ~nextcord.Forbidden
            You do not have proper permissions to get the information.
        ~nextcord.HTTPException
            An error occurred while fetching the information.

        Returns
        -------
        List[:class:`~nextcord.Invite`]
            The list of invites that are currently active.
        """
        ...
    


class Messageable:
    """An ABC that details the common operations on a model that can send messages.

    The following implement this ABC:

    - :class:`~nextcord.TextChannel`
    - :class:`~nextcord.DMChannel`
    - :class:`~nextcord.GroupChannel`
    - :class:`~nextcord.VoiceChannel`
    - :class:`~nextcord.User`
    - :class:`~nextcord.Member`
    - :class:`~nextcord.ext.commands.Context`
    - :class:`~nextcord.Thread`
    """
    __slots__ = ...
    _state: ConnectionState
    @overload
    async def send(self, content: Optional[str] = ..., *, tts: bool = ..., embed: Embed = ..., file: File = ..., stickers: Optional[Sequence[Union[GuildSticker, StickerItem]]] = ..., delete_after: Optional[float] = ..., nonce: Optional[Union[str, int]] = ..., allowed_mentions: Optional[AllowedMentions] = ..., reference: Optional[Union[Message, MessageReference, PartialMessage]] = ..., mention_author: Optional[bool] = ..., view: Optional[View] = ..., flags: Optional[MessageFlags] = ..., suppress_embeds: Optional[bool] = ...) -> Message:
        ...
    
    @overload
    async def send(self, content: Optional[str] = ..., *, tts: bool = ..., embed: Embed = ..., files: List[File] = ..., stickers: Optional[Sequence[Union[GuildSticker, StickerItem]]] = ..., delete_after: Optional[float] = ..., nonce: Optional[Union[str, int]] = ..., allowed_mentions: Optional[AllowedMentions] = ..., reference: Optional[Union[Message, MessageReference, PartialMessage]] = ..., mention_author: Optional[bool] = ..., view: Optional[View] = ..., flags: Optional[MessageFlags] = ..., suppress_embeds: Optional[bool] = ...) -> Message:
        ...
    
    @overload
    async def send(self, content: Optional[str] = ..., *, tts: bool = ..., embeds: List[Embed] = ..., file: File = ..., stickers: Optional[Sequence[Union[GuildSticker, StickerItem]]] = ..., delete_after: Optional[float] = ..., nonce: Optional[Union[str, int]] = ..., allowed_mentions: Optional[AllowedMentions] = ..., reference: Optional[Union[Message, MessageReference, PartialMessage]] = ..., mention_author: Optional[bool] = ..., view: Optional[View] = ..., flags: Optional[MessageFlags] = ..., suppress_embeds: Optional[bool] = ...) -> Message:
        ...
    
    @overload
    async def send(self, content: Optional[str] = ..., *, tts: bool = ..., embeds: List[Embed] = ..., files: List[File] = ..., stickers: Optional[Sequence[Union[GuildSticker, StickerItem]]] = ..., delete_after: Optional[float] = ..., nonce: Optional[Union[str, int]] = ..., allowed_mentions: Optional[AllowedMentions] = ..., reference: Optional[Union[Message, MessageReference, PartialMessage]] = ..., mention_author: Optional[bool] = ..., view: Optional[View] = ..., flags: Optional[MessageFlags] = ..., suppress_embeds: Optional[bool] = ...) -> Message:
        ...
    
    async def send(self, content: Optional[str] = ..., *, tts: bool = ..., embed: Optional[Embed] = ..., embeds: Optional[List[Embed]] = ..., file: Optional[File] = ..., files: Optional[List[File]] = ..., stickers: Optional[Sequence[Union[GuildSticker, StickerItem]]] = ..., delete_after: Optional[float] = ..., nonce: Optional[Union[str, int]] = ..., allowed_mentions: Optional[AllowedMentions] = ..., reference: Optional[Union[Message, MessageReference, PartialMessage]] = ..., mention_author: Optional[bool] = ..., view: Optional[View] = ..., flags: Optional[MessageFlags] = ..., suppress_embeds: Optional[bool] = ...): # -> Message:
        """|coro|

        Sends a message to the destination with the content given.

        The content must be a type that can convert to a string through ``str(content)``.
        If the content is set to ``None`` (the default), then the ``embed`` or ``embeds``
        parameter must be provided.

        To upload a single file, the ``file`` parameter should be used with a
        single :class:`~nextcord.File` object. To upload multiple files, the ``files``
        parameter should be used with a :class:`list` of :class:`~nextcord.File` objects.
        **Specifying both parameters will lead to an exception**.

        To upload a single embed, the ``embed`` parameter should be used with a
        single :class:`~nextcord.Embed` object. To upload multiple embeds, the ``embeds``
        parameter should be used with a :class:`list` of :class:`~nextcord.Embed` objects.
        **Specifying both parameters will lead to an exception**.

        Parameters
        ----------
        content: Optional[:class:`str`]
            The content of the message to send.
        tts: :class:`bool`
            Indicates if the message should be sent using text-to-speech.
        embed: :class:`~nextcord.Embed`
            The rich embed for the content.
        file: :class:`~nextcord.File`
            The file to upload.
        files: List[:class:`~nextcord.File`]
            A list of files to upload. Must be a maximum of 10.
        nonce: Union[:class:`int`, :class:`str`]
            The nonce to use for sending this message. If the message was successfully sent,
            then the message will have a nonce with this value.
        delete_after: :class:`float`
            If provided, the number of seconds to wait in the background
            before deleting the message we just sent. If the deletion fails,
            then it is silently ignored.
        allowed_mentions: :class:`~nextcord.AllowedMentions`
            Controls the mentions being processed in this message. If this is
            passed, then the object is merged with :attr:`~nextcord.Client.allowed_mentions`.
            The merging behaviour only overrides attributes that have been explicitly passed
            to the object, otherwise it uses the attributes set in :attr:`~nextcord.Client.allowed_mentions`.
            If no object is passed at all then the defaults given by :attr:`~nextcord.Client.allowed_mentions`
            are used instead.

            .. versionadded:: 1.4

        reference: Union[:class:`~nextcord.Message`, :class:`~nextcord.MessageReference`, :class:`~nextcord.PartialMessage`]
            A reference to the :class:`~nextcord.Message` to which you are replying, this can be created using
            :meth:`~nextcord.Message.to_reference` or passed directly as a :class:`~nextcord.Message`. You can control
            whether this mentions the author of the referenced message using the :attr:`~nextcord.AllowedMentions.replied_user`
            attribute of ``allowed_mentions`` or by setting ``mention_author``.

            .. versionadded:: 1.6

        mention_author: Optional[:class:`bool`]
            If set, overrides the :attr:`~nextcord.AllowedMentions.replied_user` attribute of ``allowed_mentions``.

            .. versionadded:: 1.6
        view: :class:`nextcord.ui.View`
            A Discord UI View to add to the message.
        embeds: List[:class:`~nextcord.Embed`]
            A list of embeds to upload. Must be a maximum of 10.

            .. versionadded:: 2.0
        stickers: Sequence[Union[:class:`~nextcord.GuildSticker`, :class:`~nextcord.StickerItem`]]
            A list of stickers to upload. Must be a maximum of 3.

            .. versionadded:: 2.0
        flags: Optional[:class:`~nextcord.MessageFlags`]
            The message flags being set for this message.
            Currently only :class:`~nextcord.MessageFlags.suppress_embeds` is able to be set.

            .. versionadded:: 2.4
        suppress_embeds: Optional[:class:`bool`]
            Whether to suppress embeds on this message.

            .. versionadded:: 2.4

        Raises
        ------
        ~nextcord.HTTPException
            Sending the message failed.
        ~nextcord.Forbidden
            You do not have the proper permissions to send the message.
        ~nextcord.InvalidArgument
            The ``files`` list is not of the appropriate size,
            you specified both ``file`` and ``files``,
            or you specified both ``embed`` and ``embeds``,
            or the ``reference`` object is not a :class:`~nextcord.Message`,
            :class:`~nextcord.MessageReference` or :class:`~nextcord.PartialMessage`

        Returns
        -------
        :class:`~nextcord.Message`
            The message that was sent.
        """
        ...
    
    async def trigger_typing(self) -> None:
        """|coro|

        Triggers a *typing* indicator to the destination.

        *Typing* indicator will go away after 10 seconds, or after a message is sent.
        """
        ...
    
    def typing(self) -> Typing:
        """Returns a context manager that allows you to type for an indefinite period of time.

        This is useful for denoting long computations in your bot.

        .. note::

            This is both a regular context manager and an async context manager.
            This means that both ``with`` and ``async with`` work with this.

        Example Usage: ::

            async with channel.typing():
                # simulate something heavy
                await asyncio.sleep(10)

            await channel.send('done!')

        """
        ...
    
    async def fetch_message(self, id: int, /) -> Message:
        """|coro|

        Retrieves a single :class:`~nextcord.Message` from the destination.

        Parameters
        ----------
        id: :class:`int`
            The message ID to look for.

        Raises
        ------
        ~nextcord.NotFound
            The specified message was not found.
        ~nextcord.Forbidden
            You do not have the permissions required to get a message.
        ~nextcord.HTTPException
            Retrieving the message failed.

        Returns
        -------
        :class:`~nextcord.Message`
            The message asked for.
        """
        ...
    
    def history(self, *, limit: Optional[int] = ..., before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ..., around: Optional[SnowflakeTime] = ..., oldest_first: Optional[bool] = ...) -> HistoryIterator:
        """Returns an :class:`~nextcord.AsyncIterator` that enables receiving the destination's message history.

        You must have :attr:`~nextcord.Permissions.read_message_history` permissions to use this.

        Examples
        --------

        Usage ::

            counter = 0
            async for message in channel.history(limit=200):
                if message.author == client.user:
                    counter += 1

        Flattening into a list: ::

            messages = await channel.history(limit=123).flatten()
            # messages is now a list of Message...

        All parameters are optional.

        Parameters
        ----------
        limit: Optional[:class:`int`]
            The number of messages to retrieve.
            If ``None``, retrieves every message in the channel. Note, however,
            that this would make it a slow operation.
        before: Optional[Union[:class:`~nextcord.abc.Snowflake`, :class:`datetime.datetime`]]
            Retrieve messages before this date or message.
            If a datetime is provided, it is recommended to use a UTC aware datetime.
            If the datetime is naive, it is assumed to be local time.
        after: Optional[Union[:class:`~nextcord.abc.Snowflake`, :class:`datetime.datetime`]]
            Retrieve messages after this date or message.
            If a datetime is provided, it is recommended to use a UTC aware datetime.
            If the datetime is naive, it is assumed to be local time.
        around: Optional[Union[:class:`~nextcord.abc.Snowflake`, :class:`datetime.datetime`]]
            Retrieve messages around this date or message.
            If a datetime is provided, it is recommended to use a UTC aware datetime.
            If the datetime is naive, it is assumed to be local time.
            When using this argument, the maximum limit is 101. Note that if the limit is an
            even number then this will return at most limit + 1 messages.
        oldest_first: Optional[:class:`bool`]
            If set to ``True``, return messages in oldest->newest order. Defaults to ``True`` if
            ``after`` is specified, otherwise ``False``.

        Raises
        ------
        ~nextcord.Forbidden
            You do not have permissions to get channel message history.
        ~nextcord.HTTPException
            The request to get message history failed.

        Yields
        ------
        :class:`~nextcord.Message`
            The message with the message data parsed.
        """
        ...
    


class Connectable(Protocol):
    """An ABC that details the common operations on a channel that can
    connect to a voice server.

    The following implement this ABC:

    - :class:`~nextcord.VoiceChannel`
    - :class:`~nextcord.StageChannel`

    Note
    ----
    This ABC is not decorated with :func:`typing.runtime_checkable`, so will fail :func:`isinstance`/:func:`issubclass`
    checks.
    """
    __slots__ = ...
    _state: ConnectionState
    async def connect(self, *, timeout: float = ..., reconnect: bool = ..., cls: Callable[[Client, Connectable], T] = ...) -> T:
        """|coro|

        Connects to voice and creates a :class:`VoiceClient` to establish
        your connection to the voice server.

        This requires :attr:`Intents.voice_states`.

        Parameters
        ----------
        timeout: :class:`float`
            The timeout in seconds to wait for the voice endpoint.
        reconnect: :class:`bool`
            Whether the bot should automatically attempt
            a reconnect if a part of the handshake fails
            or the gateway goes down.
        cls: Type[:class:`VoiceProtocol`]
            A type that subclasses :class:`~nextcord.VoiceProtocol` to connect with.
            Defaults to :class:`~nextcord.VoiceClient`.

        Raises
        ------
        asyncio.TimeoutError
            Could not connect to the voice channel in time.
        ~nextcord.ClientException
            You are already connected to a voice channel.
        ~nextcord.opus.OpusNotLoaded
            The opus library has not been loaded.

        Returns
        -------
        :class:`~nextcord.VoiceProtocol`
            A voice client that is fully connected to the voice server.
        """
        ...
    


