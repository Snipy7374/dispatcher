"""
This type stub file was generated by pyright.
"""

import sys
from inspect import Parameter
from typing import Any, Callable, ClassVar, Coroutine, Dict, Iterable, List, Optional, Set, TYPE_CHECKING, Tuple, Type, TypeVar, Union, overload
from .abc import Snowflake
from .enums import ApplicationCommandOptionType, ApplicationCommandType, ChannelType, Locale
from .guild import Guild
from .interactions import Interaction
from .member import Member
from .message import Message
from .permissions import Permissions
from .role import Role
from .types.interactions import ApplicationCommand as ApplicationCommandPayload, ApplicationCommandInteractionData, ApplicationCommandInteractionDataOption
from .user import User
from .state import ConnectionState
from .types.checks import ApplicationCheck, ApplicationErrorCallback, ApplicationHook

if TYPE_CHECKING:
    _CustomTypingMetaBase = Any
else:
    ...
if sys.version_info >= (3, 10):
    ...
else:
    ...
__all__ = ("CallbackWrapper", "ApplicationCommandOption", "BaseCommandOption", "OptionConverter", "ClientCog", "CallbackMixin", "SlashOption", "SlashCommandOption", "BaseApplicationCommand", "SlashApplicationSubcommand", "SlashApplicationCommand", "UserApplicationCommand", "MessageApplicationCommand", "slash_command", "message_command", "user_command", "Mentionable", "Range", "String")
_log = ...
_MAX_COMMAND_DESCRIPTION_LENGTH = ...
DEFAULT_SLASH_DESCRIPTION = ...
T = TypeVar("T")
FuncT = TypeVar("FuncT", bound=Callable[..., Any])
if TYPE_CHECKING:
    EllipsisType = ellipsis
else:
    ...
class CallbackWrapper:
    """A class used to wrap a callback in a sane way to modify aspects of application commands.

    By creating a decorator that makes this class wrap a function or an application command, you can easily modify
    attributes of the command regardless if this wraps the callback or the application command, and without needing
    to make the application command object interpret arbitrarily set function attributes.

    The ``modify`` method must be overridden.

    This handles both multiple layers of wrappers, or if it wraps around a :class:`BaseApplicationCommand`

    Parameters
    ----------
    callback: Union[Callable, :class:`CallbackWrapper`, :class:`BaseApplicationCommand`]
        Callback, other callback wrapper, or application command to wrap and/or modify.

    Examples
    --------
    Creating a decorator that makes the description of the command uppercase, and offers an "override" argument: ::

        def upper_description(description_override: str = None):
            class UpperDescription(CallbackWrapper):
                def modify(self, app_cmd):
                    if description_override is not None:
                        app_cmd.description = description_override.upper()
                    elif app_cmd.description:
                        app_cmd.description = app_cmd.description.upper()

            def wrapper(func):
                return UpperDescription(func)

            return wrapper

        @client.slash_command(description="This will be made uppercase.")
        @upper_description()
        async def test(interaction):
            await interaction.send("The description of this command should be in all uppercase!")
    """
    def __new__(cls, callback: Union[Callable, CallbackWrapper, BaseApplicationCommand, SlashApplicationSubcommand], *args, **kwargs) -> Union[CallbackWrapper, BaseApplicationCommand, SlashApplicationSubcommand]:
        ...
    
    def __init__(self, callback: Union[Callable, CallbackWrapper], *args, **kwargs) -> None:
        ...
    
    def modify(self, app_cmd: BaseApplicationCommand):
        ...
    


class CallbackWrapperMixin:
    def __init__(self, callback: Optional[Union[Callable, CallbackWrapper]]) -> None:
        """Adds very basic callback wrapper support.

        If you are a normal user, you shouldn't be using this.

        Parameters
        ----------
        callback: Union[Callable, :class:`CallbackWrapper`]
            Callback or ``CallbackWrapper`` that the application command is wrapping.
        """
        ...
    
    def modify(self) -> None:
        ...
    


class ApplicationCommandOption:
    """This represents the `Application Command Option Structure
    <https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-structure>`_
    with no frills added.

    Parameters
    ----------
    cmd_type: :class:`ApplicationCommandOptionType`
        Type of option the command should have.
    name: :class:`str`
        Display name of the option. Must be lowercase with no spaces, 1-32 characters.
    description: :class:`str`
        Description of the option. Must be 1-100 characters.
    required: :class:`bool`
        If the option is required or optional.
    name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Name(s) of the subcommand for users of specific locales. The locale code should be the key, with the
        localized name as the value
    description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
        localized description as the value.
    choices: Union[Dict[:class:`str`, Union[:class:`str`, :class:`int`, :class:`float`]],
             Iterable[Union[:class:`str`, :class:`int`, :class:`float`]]]
        Either a dictionary of display name: value pairs, or an iterable list of values that will have identical
        display names and values.
    choice_localizations: Dict[:class:`str`, Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]]
        A dictionary of choice display names as the keys, and dictionaries of locale: localized name as the values.
    channel_types: List[:class:`ChannelType`]
        A list of ChannelType enums to allow the user to pick. Should only be set if this is a Channel option.
    min_value: Union[:class:`int`, :class:`float`]
        Minimum value the user can input. Should only be set if this is an integer or number option.
    max_value: Union[:class:`int`, :class:`float`]
        Minimum value the user can input. Should only be set if this is an integer or number option.
    min_length: :class:`int`
        Minimum length of a string the user can input. Should only be set if this is a string option.

        .. versionadded:: 2.1
    max_length: :class:`int`
        Maximum length of a string the user can input. Should only be set if this is a string option.

        .. versionadded:: 2.1
    autocomplete: :class:`bool`
        If the command option should have autocomplete enabled.
    """
    def __init__(self, name: Optional[str] = ..., description: Optional[str] = ..., required: Optional[bool] = ..., *, cmd_type: Optional[ApplicationCommandOptionType] = ..., name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., choices: Union[Dict[str, Union[str, int, float]], Iterable[Union[str, int, float]], None] = ..., choice_localizations: Optional[Dict[str, Dict[Union[Locale, str], str]]] = ..., channel_types: Optional[List[ChannelType]] = ..., min_value: Union[int, float, None] = ..., max_value: Union[int, float, None] = ..., min_length: Optional[int] = ..., max_length: Optional[int] = ..., autocomplete: Optional[bool] = ...) -> None:
        ...
    
    def get_name_localization_payload(self) -> Optional[Dict[str, str]]:
        ...
    
    def get_description_localization_payload(self) -> Optional[Dict[str, str]]:
        ...
    
    def get_choices_localized_payload(self) -> List[Dict[str, Union[str, int, float, dict, None]]]:
        ...
    
    @property
    def payload(self) -> dict:
        """:class:`dict`: Returns a dict payload made of the attributes of the option to be sent to Discord."""
        ...
    


class BaseCommandOption(ApplicationCommandOption):
    """Represents an application command option, but takes a :class:`Parameter` and :class:`ClientCog` as
    an argument.

    Parameters
    ----------
    parameter: :class:`Parameter`
        Function parameter to construct the command option with.
    command: Union[:class:`BaseApplicationCommand`, :class:`SlashApplicationSubcommand`]
        Application Command this option is for.
    parent_cog: :class:`ClientCog`
        Class that the function the option is for resides in.
    """
    def __init__(self, parameter: Parameter, command: Union[BaseApplicationCommand, SlashApplicationSubcommand], parent_cog: Optional[ClientCog] = ...) -> None:
        ...
    
    @property
    def error_name(self) -> str:
        ...
    


class OptionConverter(_CustomTypingMetaBase):
    """Based on, in basic functionality, the ``ext.commands`` Converter. Users subclass this and use convert to
    provide custom "typings" for slash commands.

    The ``convert`` method MUST be overridden to convert the value from Discord to the desired value.
    The ``modify`` method MAY be overridden to modify the :class:`BaseCommandOption`.
    """
    def __init__(self, option_type: Union[type, ApplicationCommandOptionType] = ...) -> None:
        """Initializes the converter.

        Parameters
        ----------
        option_type: Union[:class:`type`, :class:`ApplicationCommandOptionType`]
            Option type to forward to Discord.
        """
        ...
    
    async def convert(self, interaction: Interaction, value: Any) -> Any:
        """|coro|
        Called to convert a value received from Discord to the desired value.

        If you do not wish to do any conversion, simply ``return`` the ``value``

        Parameters
        ----------
        interaction: :class:`Interaction`
            Interaction associated with the usage of the application command.
        value: Any
            Value received from Discord.

        Returns
        -------
        Any
            Converted value to forward to the callback.
        """
        ...
    
    def modify(self, option: BaseCommandOption) -> None:
        """Called when the command is being parsed to allow for option modification.

        Parameters
        ----------
        option: :class:`BaseCommandOption`
            Command option that's being created.
        """
        ...
    


class Mentionable(OptionConverter):
    """When a parameter is typehinted with this, it allows users to select both roles and members."""
    def __init__(self) -> None:
        ...
    
    async def convert(self, interaction: Interaction, value: Any) -> Any:
        ...
    


class ClientCog:
    __cog_application_commands__: List[BaseApplicationCommand]
    def __new__(cls, *args: Any, **kwargs: Any): # -> Self@ClientCog:
        ...
    
    @property
    def application_commands(self) -> List[BaseApplicationCommand]:
        """Provides the list of application commands in this cog. Subcommands are not included."""
        ...
    
    def process_app_cmds(self) -> None:
        """Formats all added application commands with their callback."""
        ...
    
    @_cog_special_method
    def cog_application_command_check(self, interaction: Interaction) -> bool:
        """A special method that registers as a :func:`.ext.application_checks.check`
        for every application command and subcommand in this cog.

        This function **can** be a coroutine and must take a sole parameter,
        ``interaction``, to represent the :class:`.Interaction`.
        """
        ...
    
    @_cog_special_method
    async def cog_application_command_before_invoke(self, interaction: Interaction) -> None:
        """A special method that acts as a cog local pre-invoke hook.

        This is similar to :meth:`.ApplicationCommand.before_invoke`.

        This **must** be a coroutine.

        Parameters
        ----------
        interaction: :class:`.Interaction`
            The invocation interaction.
        """
        ...
    
    @_cog_special_method
    async def cog_application_command_after_invoke(self, interaction: Interaction) -> None:
        """A special method that acts as a cog local post-invoke hook.

        This is similar to :meth:`.Command.after_invoke`.

        This **must** be a coroutine.

        Parameters
        ----------
        interaction: :class:`.Interaction`
            The invocation interaction.
        """
        ...
    


class CallbackMixin:
    name: Optional[str]
    options: Dict[str, BaseCommandOption]
    def __init__(self, callback: Optional[Callable] = ..., parent_cog: Optional[ClientCog] = ...) -> None:
        """Contains code specific for adding callback support to a command class.

        If you are a normal user, you shouldn't be using this.

        Parameters
        ----------
        callback: Optional[:data:`~typing.Callable`]
            Callback to create options from and invoke. If provided, it must be a coroutine function.
        parent_cog: Optional[:class:`ClientCog`]
            Class that the callback resides on. Will be passed into the callback if provided.
        """
        ...
    
    def __call__(self, interaction: Interaction, *args, **kwargs):
        """Invokes the callback, injecting ``self`` if available."""
        ...
    
    @property
    def error_name(self) -> str:
        """Returns a string containing the class name, command name, and the callback to use in raising exceptions.

        Examples
        --------
        >>> print(app_cmd.error_name)
        SlashApplicationCommand reloadme <function TinyTest.reloadme at 0x7f4b3b563e20>


        Returns
        -------
        :class:`str`
            String containing the class name, command name, and callback object.
        """
        ...
    
    @property
    def cog_before_invoke(self) -> Optional[ApplicationHook]:
        """Returns the cog_application_command_before_invoke method for the cog that this command is in.
        Returns ``None`` if not the method is not found.

        Returns
        -------
        Optional[:class:`ApplicationHook`]
            ``before_invoke`` method from the parent cog. ``None`` if not the method is not found.
        """
        ...
    
    @property
    def cog_after_invoke(self) -> Optional[ApplicationHook]:
        """Returns the cog_application_command_after_invoke method for the cog that this command is in.

        Returns
        -------
        Optional[:class:`ApplicationHook`]
            ``after_invoke`` method from the parent cog. ``None`` if not the method is not found.
        """
        ...
    
    def has_error_handler(self) -> bool:
        """:class:`bool`: Checks whether the command has an error handler registered."""
        ...
    
    def add_check(self, func: ApplicationCheck) -> CallbackMixin:
        """Adds a check to the application command. Returns the application command for method chaining.

        Parameters
        ----------
        func: :class:`ApplicationCheck`
            The function that will be used as a check.
        """
        ...
    
    def remove_check(self, func: ApplicationCheck) -> CallbackMixin:
        """Removes a check from the ApplicationCommand. Returns the application command for method chaining.

        This function is idempotent and will not raise an exception
        if the function is not in the command's checks.

        Parameters
        ----------
        func: :class:`ApplicationCheck`
            The function to remove from the checks.
        """
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Optional[Type[BaseCommandOption]] = ...) -> None:
        """Creates objects of type ``option_class`` with the parameters of the function, and stores them in
        the options attribute.

        Parameters
        ----------
        callback: Optional[:data:`~typing.Callable`]
            Callback to create options from. Must be a coroutine function.
        option_class: Optional[Type[:class:`BaseCommandOption`]]
            Class to create the options using. Should either be or subclass :class:`BaseCommandOption`. Defaults
            to :class:`BaseCommandOption`.

        Returns
        -------
        :class:`CallbackMixin`
            Self for possible chaining.

        """
        ...
    
    async def can_run(self, interaction: Interaction) -> bool:
        """|coro|

        Checks if the command can be executed by checking all the predicates
        inside the :attr:`~ApplicationCommand.checks` attribute, as well as all global and cog checks.

        Parameters
        ----------
        interaction: :class:`.Interaction`
            The interaction of the command currently being invoked.

        Raises
        ------
        :class:`ApplicationError`
            Any application command error that was raised during a check call will be propagated
            by this function.

        Returns
        -------
        :class:`bool`
            A boolean indicating if the command can be invoked.
        """
        ...
    
    async def invoke_callback_with_hooks(self, state: ConnectionState, interaction: Interaction, args: Optional[tuple] = ..., kwargs: Optional[Dict[str, Any]] = ...) -> None:
        """|coro|
        Invokes the callback with all hooks and checks.
        """
        ...
    
    async def invoke_callback(self, interaction: Interaction, *args, **kwargs) -> None:
        """|coro|
        Invokes the callback, injecting ``self`` if available.
        """
        ...
    
    async def invoke_error(self, interaction: Interaction, error: Exception) -> None:
        """|coro|
        Invokes the error handler if available.
        """
        ...
    
    def error(self, callback: ApplicationErrorCallback) -> Callable:
        """Decorates a function, setting it as a callback to be called when a :class:`ApplicationError` or any of
        its subclasses is raised inside the :class:`ApplicationCommand`.

        Parameters
        ----------
        callback: Callable[[:class:`Interaction`, :class:`ApplicationError`], :class:`asyncio.Awaitable[Any]`]
            The callback to call when an error occurs.
        """
        ...
    
    def before_invoke(self, coro: Callable[[Interaction], Coroutine]) -> Callable[[Interaction], Coroutine]:
        """Sets the callback that should be run before the command callback is invoked.

        Parameters
        ----------
        coro: Callable[[:class:`Interaction`], Coroutine]
            Coroutine to set as the before_invoke hook.

        Returns
        -------
        Callable[[:class:`Interaction`], Coroutine]
            The coroutine to allow multiple commands to share the function.
        """
        ...
    
    def after_invoke(self, coro: Callable[[Interaction], Coroutine]) -> Callable[[Interaction], Coroutine]:
        """Sets the callback that should be run after the command callback is invoked.

        Parameters
        ----------
        coro: Callable[[:class:`Interaction`], Coroutine]
            Coroutine to set as the after_invoke hook.

        Returns
        -------
        Callable[[:class:`Interaction`], Coroutine]
            The coroutine to allow multiple commands to share the function.
        """
        ...
    


class AutocompleteOptionMixin:
    def __init__(self, autocomplete_callback: Optional[Callable] = ..., parent_cog: Optional[ClientCog] = ...) -> None:
        """Contains code for providing autocomplete support, specifically for options.

        If you are a normal user, you shouldn't be using this.

        Parameters
        ----------
        autocomplete_callback: Optional[:data:`~typing.Callable`]
            Callback to create options from and invoke. If provided, it must be a coroutine function.
        parent_cog: Optional[:class:`ClientCog`]
            Class that the callback resides on. Will be passed into the callback if provided.

        """
        ...
    
    def from_autocomplete_callback(self, callback: Callable) -> AutocompleteOptionMixin:
        """Parses a callback meant to be the autocomplete function."""
        ...
    
    async def invoke_autocomplete_callback(self, interaction: Interaction, option_value: Any, **kwargs) -> None:
        """|coro|
        Invokes the autocomplete callback, injecting ``self`` if available.
        """
        ...
    


class AutocompleteCommandMixin:
    options: Dict[str, SlashCommandOption]
    children: Dict[str, SlashApplicationSubcommand]
    _state: ConnectionState
    def __init__(self, parent_cog: Optional[ClientCog] = ...) -> None:
        """Contains code for providing autocomplete support, specifically for application commands.

        If you are a normal user, you shouldn't be using this.

        Parameters
        ----------
        parent_cog: Optional[:class:`ClientCog`]
            Class that the callback resides on. Will be passed into the callback if provided.
        """
        ...
    
    async def call_autocomplete_from_interaction(self, interaction: Interaction) -> None:
        """|coro|
        Calls the autocomplete callback with the given interaction.
        """
        ...
    
    async def call_autocomplete(self, state: ConnectionState, interaction: Interaction, option_data: Optional[List[Dict[str, Any]]] = ...) -> None:
        """|coro|
        Calls the autocomplete callback with the given interaction and option data.
        """
        ...
    
    def from_autocomplete(self) -> None:
        """Processes the found autocomplete callbacks and associates them to their corresponding options.

        Raises
        ------
        :class:`ValueError`
            If a found arg name doesn't correspond to an autocomplete function.
        """
        ...
    
    def on_autocomplete(self, on_kwarg: str): # -> (func: (...) -> Unknown) -> ((...) -> Unknown):
        """Decorator that adds an autocomplete callback to the given kwarg.

        .. code-block:: python3

            @bot.slash_command()
            async def your_favorite_dog(interaction: Interaction, dog: str):
                await interaction.response.send_message(f"Your favorite dog is {dog}!")

            @your_favorite_dog.on_autocomplete("dog")
            async def favorite_dog(interaction: Interaction, dog: str):
                if not dog:
                    # send the full autocomplete list
                    await interaction.response.send_autocomplete(list_of_dog_breeds)
                    return
                # send a list of nearest matches from the list of dog breeds
                get_near_dog = [breed for breed in list_of_dog_breeds if breed.lower().startswith(dog.lower())]
                await interaction.response.send_autocomplete(get_near_dog)

        .. note::
            To use inputs from other options inputted in the command, you can add them as arguments to the autocomplete
            callback. The order of the arguments does not matter, but the names do.

        Parameters
        ----------
        on_kwarg: :class:`str`
            The slash command option to add the autocomplete callback to.
        """
        ...
    
    @property
    def error_name(self) -> str:
        ...
    


class SlashOption(ApplicationCommandOption, _CustomTypingMetaBase):
    """Provides Discord with information about an option in a command.

    When this class is set as the default argument of a parameter in an Application Command, additional information
    about the parameter is sent to Discord for the user to see.

    Parameters
    ----------
    name: :class:`str`
        The name of the Option on Discords side. If left as None, it defaults to the parameter name.
    description: :class:`str`
        The description of the Option on Discords side. If left as None, it defaults to "".
    required: :class:`bool`
        If a user is required to provide this argument before sending the command.
    name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Name(s) of the subcommand for users of specific locales. The locale code should be the key, with the
        localized name as the value
    description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
        localized description as the value
    choices: Union[Dict[:class:`str`, Union[:class:`str`, :class:`int`, :class:`float`]],
             Iterable[Union[:class:`str`, :class:`int`, :class:`float`]]]
        A list of choices that a user must choose.
        If a :class:`dict` is given, the keys are what the users are able to see, the values are what is sent back
        to the bot.
        Otherwise, it is treated as an :class:`~collections.abc.Iterable` where what the user sees and is sent back to the bot are the same.
    choice_localizations: Dict[:class:`str`, Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]]
        A dictionary of choice display names as the keys, and dictionaries of locale: localized name as the values.
    channel_types: List[:class:`ChannelType`]
        List of :class:`ChannelType` enums, limiting the users choice to only those channel types. The parameter must be
        typed as :class:`GuildChannel` for this to function.
    min_value: Union[:class:`int`, :class:`float`]
        Minimum integer or floating point value the user is allowed to input. The parameter must be typed as an
        :class:`int` or :class:`float` for this to function.
    max_value: Union[:class:`int`, :class:`float`]
        Maximum integer or floating point value the user is allowed to input. The parameter must be typed as an
        :class:`int` or :class:`float` for this to function.
    min_length: :class:`int`
        Minimum length for a string value the user is allowed to input. The parameter must be typed as a
        :class:`str` for this to function.

        .. versionadded:: 2.1
    max_length: :class:`int`
        Maximum length for a string value the user is allowed to input. The parameter must be typed as a
        :class:`str` for this to function.

        .. versionadded:: 2.1
    autocomplete: :class:`bool`
        If this parameter has an autocomplete function decorated for it. If unset, it will automatically be ``True``
        if an autocomplete function for it is found.
    autocomplete_callback: Optional[:data:`~typing.Callable`]
        The function that will be used to autocomplete this parameter. If not specified, it will be looked for
        using the :meth:`~SlashApplicationCommand.on_autocomplete` decorator.
    default: Any
        When required is not True and the user doesn't provide a value for this Option, this value is given instead.
    verify: :class:`bool`
        If True, the given values will be checked to ensure that the payload to Discord is valid.
    """
    def __init__(self, name: Optional[str] = ..., description: Optional[str] = ..., required: Optional[bool] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., choices: Union[Dict[str, Union[str, int, float]], Iterable[Union[str, int, float]], None] = ..., choice_localizations: Optional[Dict[str, Dict[Union[Locale, str], str]]] = ..., channel_types: Optional[List[ChannelType]] = ..., min_value: Union[int, float, None] = ..., max_value: Union[int, float, None] = ..., min_length: Optional[int] = ..., max_length: Optional[int] = ..., autocomplete: Optional[bool] = ..., autocomplete_callback: Optional[Callable] = ..., default: Any = ..., verify: bool = ...) -> None:
        ...
    
    def verify(self) -> bool:
        """Checks if the given values conflict with one another or are invalid."""
        ...
    


class SlashCommandOption(BaseCommandOption, SlashOption, AutocompleteOptionMixin):
    command: Union[SlashApplicationCommand, SlashApplicationSubcommand]
    option_types: Dict[type, ApplicationCommandOptionType] = ...
    channel_mapping: Dict[type, Tuple[ChannelType, ...]] = ...
    def __init__(self, parameter: Parameter, command: Union[SlashApplicationCommand, SlashApplicationSubcommand], parent_cog: Optional[ClientCog] = ...) -> None:
        ...
    
    @property
    def description(self) -> str:
        """:class:`str`: If no description is set, it returns "No description provided" """
        ...
    
    @description.setter
    def description(self, value: str) -> None:
        ...
    
    def get_type(self, param_typing: Union[type, OptionConverter, ApplicationCommandOptionType]) -> ApplicationCommandOptionType:
        ...
    
    def verify(self) -> bool:
        """This should run through :class:`SlashOption` variables and raise errors when conflicting data is given."""
        ...
    
    async def handle_value(self, state: ConnectionState, value: Any, interaction: Interaction) -> Any:
        ...
    


class SlashCommandMixin(CallbackMixin):
    if TYPE_CHECKING:
        _description: Optional[str]
        command_ids: Dict[Optional[int], int]
        qualified_name: str
        _children: Dict[str, SlashApplicationSubcommand]
        ...
    def __init__(self, callback: Optional[Callable], parent_cog: Optional[ClientCog]) -> None:
        ...
    
    @property
    def children(self) -> Dict[str, SlashApplicationSubcommand]:
        """Returns the sub-commands and sub-command groups of the command.

        .. versionchanged:: 2.3
            ``.children`` is now a read-only property.
        """
        ...
    
    @property
    def description(self) -> str:
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Optional[Type[SlashCommandOption]] = ...): # -> None:
        ...
    
    async def get_slash_kwargs(self, state: ConnectionState, interaction: Interaction, option_data: Optional[List[ApplicationCommandInteractionDataOption]] = ...) -> Dict[str, Any]:
        ...
    
    async def call_slash(self, state: ConnectionState, interaction: Interaction, option_data: Optional[List[ApplicationCommandInteractionDataOption]] = ...): # -> None:
        ...
    
    def get_mention(self, guild: Optional[Snowflake] = ...) -> str:
        """Returns a string that allows you to mention the slash command.

        .. versionadded:: 2.2

        Parameters
        ----------
        guild: Optional[:class:`~abc.Snowflake`]
            The :class:`Guild` of the command to mention. If ``None``, then the global command will be mentioned.

        Returns
        -------
        :class:`str`
            The string that allows you to mention the slash command.

        Raises
        ------
        ValueError
            If no guild was provided and the command is not registered globally, or the command is not registered
            in the guild provided.
        """
        ...
    


class BaseApplicationCommand(CallbackMixin, CallbackWrapperMixin):
    """Base class for all application commands.

    Attributes
    ----------
    checks: List[Union[Callable[[:class:`ClientCog`, :class:`Interaction`], MaybeCoro[:class:`bool`]], Callable[[:class:`Interaction`], MaybeCoro[:class:`bool`]]]]
        A list of predicates that verifies if the command could be executed
        with the given :class:`Interaction` as the sole parameter. If an exception
        is necessary to be thrown to signal failure, then one inherited from
        :exc:`.ApplicationError` should be used. Note that if the checks fail then
        :exc:`.ApplicationCheckFailure` exception is raised to the :func:`.on_application_command_error`
        event.
    """
    def __init__(self, name: Optional[str] = ..., description: Optional[str] = ..., *, cmd_type: ApplicationCommandType, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., callback: Optional[Callable] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., parent_cog: Optional[ClientCog] = ..., force_global: bool = ...) -> None:
        """Base application command class that all specific application command classes should subclass. All common
        behavior should be here, with subclasses either adding on or overriding specific aspects of this class.

        Parameters
        ----------
        cmd_type: :class:`ApplicationCommandType`
            Type of application command. This should be set by subclasses.
        name: :class:`str`
            Name of the command.
        description: :class:`str`
            Description of the command.
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the command for users of specific locales. The locale code should be the key, with the localized
            name as the value.
        description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Description(s) of the command for users of specific locales. The locale code should be the key, with the
            localized description as the value.
        callback: :data:`~typing.Callable`
            Callback to make the application command from, and to run when the application command is called.
        guild_ids: Iterable[:class:`int`]
            An iterable list/set/whatever of guild ID's that the application command should register to.
            If not passed and :attr:`Client.default_guild_ids` is set, then those default guild ids will
            be used instead. If both of those are unset, then the command will be a global command.
        dm_permission: :class:`bool`
            If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
            usable in DMs. Only for global commands, but will not error on guild.
        default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
            Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
            example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
            default. Server owners CAN override the permission requirements.
        nsfw: :class:`bool`
            Whether the command can only be used in age-restricted channels. Defaults to ``False``.

            .. versionadded:: 2.4
        parent_cog: Optional[:class:`ClientCog`]
            ``ClientCog`` to forward to the callback as the ``self`` argument.
        force_global: :class:`bool`
            If this command should be registered as a global command, ALONG WITH all guild IDs set.
        """
        ...
    
    @property
    def qualified_name(self) -> str:
        """:class:`str`: Retrieves the fully qualified command name.

        .. versionadded:: 2.1
        """
        ...
    
    @property
    def description(self) -> str:
        """The description the command should have in Discord. Should be 1-100 characters long."""
        ...
    
    @description.setter
    def description(self, new_description: str) -> None:
        ...
    
    @property
    def is_guild(self) -> bool:
        """:class:`bool`: Returns ``True`` if this command is or should be registered to any guilds."""
        ...
    
    @property
    def guild_ids(self) -> Set[int]:
        """Returns a :class:`set` containing all guild ID's this command is registered to."""
        ...
    
    def add_guild_rollout(self, guild: Union[int, Guild]) -> None:
        """Adds a Guild to the command to be rolled out to when the rollout is run.

        Parameters
        ----------
        guild: Union[:class:`int`, :class:`Guild`]
            Guild or Guild ID to add this command to roll out to.
        """
        ...
    
    @property
    def is_global(self) -> bool:
        """:class:`bool`: Returns ``True`` if this command is or should be a global command."""
        ...
    
    def get_signature(self, guild_id: Optional[int] = ...) -> Tuple[Optional[str], int, Optional[int]]:
        """Returns a command signature with the given guild ID.

        Parameters
        ----------
        guild_id: Optional[:class:`None`]
            Guild ID to make the signature for. If set to ``None``, it acts as a global command signature.

        Returns
        -------
        Tuple[:class:`str`, :class:`int`, Optional[:class:`int`]]
            A tuple that acts as a signature made up of the name, type, and guild ID.
        """
        ...
    
    def get_rollout_signatures(self) -> Set[Tuple[str, int, Optional[int]]]:
        """Returns all signatures that this command wants to roll out to.

        Command signatures are made up of the command name, command type, and Guild ID (``None`` for global).

        Returns
        -------
        Set[Tuple[:class:`str`, :class:`int`, Optional[:class:`int`]]]
            A set of tuples that act as signatures.
        """
        ...
    
    def get_signatures(self) -> Set[Tuple[str, int, Optional[int]]]:
        """Returns all the signatures that this command has.

        Command signatures are made up of the command name, command type, and Guild ID (``None`` for global).

        Returns
        -------
        Set[Tuple[:class:`str`, :class:`int`, Optional[:class:`int`]]]
            A set of tuples that act as signatures.
        """
        ...
    
    def get_name_localization_payload(self) -> Optional[Dict[str, str]]:
        ...
    
    def get_description_localization_payload(self) -> Optional[dict]:
        ...
    
    def get_default_member_permissions_value(self) -> Optional[int]:
        ...
    
    def get_payload(self, guild_id: Optional[int]) -> dict:
        """Makes an Application Command payload for this command to upsert to Discord with the given Guild ID.

        Parameters
        ----------
        guild_id: Optional[:class:`int`]
            Guild ID that this payload is for. If set to ``None``, it will be a global command payload instead.

        Returns
        -------
        :class:`dict`
            Dictionary payload to upsert to Discord.
        """
        ...
    
    def parse_discord_response(self, state: ConnectionState, data: Union[ApplicationCommandInteractionData, ApplicationCommandPayload]) -> None:
        """Parses the application command creation/update response from Discord.

        Parameters
        ----------
        state: :class:`ConnectionState`
            Connection state to use internally in the command.
        data: Union[:class:`ApplicationCommandInteractionData`, :class:`ApplicationCommand`]
            Raw dictionary data from Discord.
        """
        ...
    
    def is_payload_valid(self, raw_payload: ApplicationCommandPayload, guild_id: Optional[int] = ...) -> bool:
        """Checks if the given raw application command interaction payload from Discord is possibly valid for
        this command.
        Note that while this may return ``True`` for a given payload, that doesn't mean that the payload is fully
        correct for this command. Discord doesn't send data for parameters that are optional and aren't supplied by
        the user.

        Parameters
        ----------
        raw_payload: :class:`dict`
            Application command interaction payload from Discord.
        guild_id: Optional[:class:`int`]
            Guild ID that the payload is from. If it's from a global command, this should be ``None``

        Returns
        -------
        :class:`bool`
            ``True`` if the given payload is possibly valid for this command. ``False`` otherwise.
        """
        ...
    
    def is_interaction_valid(self, interaction: Interaction) -> bool:
        """Checks if the interaction given is possibly valid for this command.
        If the command has more parameters (especially optionals) than the interaction coming in, this may cause a
        desync between your bot and Discord.

        Parameters
        ----------
        interaction: :class:`Interaction`
            Interaction to validate.

        Returns
        -------
        :class:`bool`
            ``True`` If the interaction could possibly be for this command, ``False`` otherwise.
        """
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Optional[Type[BaseCommandOption]] = ...) -> None:
        ...
    
    async def call_from_interaction(self, interaction: Interaction) -> None:
        """|coro|
        Calls the callback via the given :class:`Interaction`, relying on the locally
        stored :class:`ConnectionState` object.

        Parameters
        ----------
        interaction: :class:`Interaction`
            Interaction corresponding to the use of the command.
        """
        ...
    
    async def call(self, state: ConnectionState, interaction: Interaction) -> None:
        """|coro|
        Calls the callback via the given :class:`Interaction`, using the given :class:`ConnectionState` to get resolved
        objects if needed and available.

        Parameters
        ----------
        state: :class:`ConnectionState`
            State object to get resolved objects from.
        interaction: :class:`Interaction`
            Interaction corresponding to the use of the command.
        """
        ...
    
    def check_against_raw_payload(self, raw_payload: ApplicationCommandPayload, guild_id: Optional[int] = ...) -> bool:
        ...
    
    def get_guild_payload(self, guild_id: int): # -> dict[Unknown, Unknown]:
        ...
    
    @property
    def global_payload(self) -> dict:
        ...
    


class SlashApplicationSubcommand(SlashCommandMixin, AutocompleteCommandMixin, CallbackWrapperMixin):
    """Class representing a subcommand or subcommand group of a slash command."""
    def __init__(self, name: Optional[str] = ..., description: Optional[str] = ..., *, cmd_type: ApplicationCommandOptionType, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., callback: Optional[Callable] = ..., parent_cmd: Union[SlashApplicationCommand, SlashApplicationSubcommand, None] = ..., parent_cog: Optional[ClientCog] = ..., inherit_hooks: bool = ...) -> None:
        """Slash Application Subcommand, supporting additional subcommands and autocomplete.

        Parameters
        ----------
        name: :class:`str`
            Name of the subcommand (group). No capital letters or spaces. Defaults to the name of the callback.
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized name as the value.
        description: :class:`str`
            Description of the subcommand (group). Must be between 1-100 characters. If not provided, a default value
            will be given.
        description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized description as the value.
        callback: :class:`str`
            Callback to create the command from, and run when the command is called. If provided, it
            must be a coroutine. If this subcommand has subcommands, the callback will never be called.
        parent_cmd: Union[:class:`SlashApplicationCommand`, :class:`SlashApplicationSubcommand`]
            Parent (sub)command for this subcommand.
        cmd_type: :class:`ApplicationCommandOptionType`
            Should either be ``ApplicationCommandOptionType.sub_command`` or
            ``ApplicationCommandOptionType.sub_command_group``
        parent_cog: Optional[:class:`ClientCog`]
            Parent cog for the callback, if it exists. If provided, it will be given to the callback as ``self``.
        inherit_hooks: :class:`bool`
            If this subcommand should inherit the parent (sub)commands ``before_invoke`` and ``after_invoke`` callbacks.
            Defaults to ``False``..
        """
        ...
    
    @property
    def qualified_name(self) -> str:
        """:class:`str`: Retrieve the command name including all parents space separated.

        An example of the output would be ``parent group subcommand``.

        .. versionadded:: 2.1
        """
        ...
    
    async def call(self, state: ConnectionState, interaction: Interaction, option_data: Optional[List[ApplicationCommandInteractionDataOption]]) -> None:
        """|coro|
        Calls the callback via the given :class:`Interaction`, using the given :class:`ConnectionState` to get resolved
        objects if needed and available and the given option data.

        Parameters
        ----------
        state: :class:`ConnectionState`
            State object to get resolved objects from.
        interaction: :class:`Interaction`
            Interaction corresponding to the use of the subcommand.
        option_data: List[:class:`dict`]
            List of raw option data from Discord.
        """
        ...
    
    def get_name_localization_payload(self) -> Optional[dict]:
        ...
    
    def get_description_localization_payload(self) -> Optional[dict]:
        ...
    
    @property
    def payload(self) -> dict:
        """Returns a dict payload made of the attributes of the subcommand (group) to be sent to Discord."""
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Type[SlashCommandOption] = ..., call_children: bool = ...) -> None:
        ...
    
    def subcommand(self, name: Optional[str] = ..., description: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., inherit_hooks: bool = ...) -> Callable[[Callable], SlashApplicationSubcommand]:
        """Takes the decorated callback and turns it into a :class:`SlashApplicationSubcommand` added as a subcommand.

        Parameters
        ----------
        name: :class:`str`
            Name of the command that users will see. If not set, it defaults to the name of the callback.
        description: :class:`str`
            Description of the command that users will see. If not specified, the docstring will be used.
            If no docstring is found for the command callback, it defaults to "No description provided".
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the command for users of specific locales. The locale code should be the key, with the localized
            name as the value.
        description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized description as the value.
        inherit_hooks: :class:`bool`
            If the subcommand should inherit the parent subcommands ``before_invoke`` and ``after_invoke`` callbacks.
            Defaults to ``False``.
        """
        ...
    
    @property
    def command_ids(self) -> Dict[Optional[int], int]:
        """Dict[Optional[:class:`int`], :class:`int`]: Command IDs the parent command of this subcommand currently has.
        Schema: {Guild ID (None for global): command ID}

        .. versionadded:: 2.2
        """
        ...
    


class SlashApplicationCommand(SlashCommandMixin, BaseApplicationCommand, AutocompleteCommandMixin):
    """Class representing a slash command."""
    def __init__(self, name: Optional[str] = ..., description: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., callback: Optional[Callable] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., parent_cog: Optional[ClientCog] = ..., force_global: bool = ...) -> None:
        """Represents a Slash Application Command built from the given callback, able to be registered to multiple
        guilds or globally.

        Parameters
        ----------
        name: :class:`str`
            Name of the command. Must be lowercase with no spaces.
        description: :class:`str`
            Description of the command. Must be between 1 to 100 characters, or defaults to a set string.
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized name as the value.
        description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized description as the value.
        callback: :data:`~typing.Callable`
            Callback to make the application command from, and to run when the application command is called.
        guild_ids: Iterable[:class:`int`]
            An iterable list of guild ID's that the application command should register to.
        dm_permission: :class:`bool`
            If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
            usable in DMs. Only for global commands.
        default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
            Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
            example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
            default. Server owners CAN override the permission requirements.
        nsfw: :class:`bool`
            Whether the command can only be used in age-restricted channels. Defaults to ``False``.

            .. note::

                Due to a discord limitation, this can only be set for the parent command in case of a subcommand.

            .. versionadded:: 2.4
        parent_cog: Optional[:class:`ClientCog`]
            ``ClientCog`` to forward to the callback as the ``self`` argument.
        force_global: :class:`bool`
            If this command should be registered as a global command, ALONG WITH all guild IDs set.
        """
        ...
    
    @property
    def description(self) -> str:
        ...
    
    @description.setter
    def description(self, new_desc: str) -> None:
        ...
    
    def get_payload(self, guild_id: Optional[int]): # -> dict[Unknown, Unknown]:
        ...
    
    async def call(self, state: ConnectionState, interaction: Interaction) -> None:
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Type[SlashCommandOption] = ..., call_children: bool = ...) -> None:
        ...
    
    def subcommand(self, name: Optional[str] = ..., description: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., inherit_hooks: bool = ...) -> Callable[[Callable], SlashApplicationSubcommand]:
        """Takes the decorated callback and turns it into a :class:`SlashApplicationSubcommand` added as a subcommand.

        Parameters
        ----------
        name: :class:`str`
            Name of the command that users will see. If not set, it defaults to the name of the callback.
        description: :class:`str`
            Description of the command that users will see. If not specified, the docstring will be used.
            If no docstring is found for the command callback, it defaults to "No description provided".
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the command for users of specific locales. The locale code should be the key, with the localized
            name as the value.
        description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized description as the value.
        inherit_hooks: :class:`bool`
            If the subcommand should inherit the parent commands ``before_invoke`` and ``after_invoke`` callbacks.
            Defaults to ``False``.
        """
        ...
    


class UserApplicationCommand(BaseApplicationCommand):
    """Class representing a user context menu command."""
    def __init__(self, name: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., callback: Optional[Callable] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., parent_cog: Optional[ClientCog] = ..., force_global: bool = ...) -> None:
        """Represents a User Application Command that will give the user to the given callback, able to be registered to
        multiple guilds or globally.

        Parameters
        ----------
        name: :class:`str`
            Name of the command. Can be uppercase with spaces.
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized name as the value.
        callback: :data:`~typing.Callable`
            Callback to run with the application command is called.
        guild_ids: Iterable[:class:`int`]
            An iterable list of guild ID's that the application command should register to.
        dm_permission: :class:`bool`
            If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
            usable in DMs. Only for global commands, but will not error on guild.
        default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
            Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
            example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
            default. Server owners CAN override the permission requirements.
        nsfw: :class:`bool`
            Whether the command can only be used in age-restricted channels. Defaults to ``False``.

            .. versionadded:: 2.4
        parent_cog: Optional[:class:`ClientCog`]
            ``ClientCog`` to forward to the callback as the ``self`` argument.
        force_global: :class:`bool`
            If this command should be registered as a global command, ALONG WITH all guild IDs set.
        """
        ...
    
    @property
    def description(self) -> str:
        ...
    
    @description.setter
    def description(self, new_desc: str):
        ...
    
    async def call(self, state: ConnectionState, interaction: Interaction) -> None:
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Optional[Type[BaseCommandOption]] = ...) -> None:
        ...
    


class MessageApplicationCommand(BaseApplicationCommand):
    """Class representing a message context menu command."""
    def __init__(self, name: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., callback: Optional[Callable] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., parent_cog: Optional[ClientCog] = ..., force_global: bool = ...) -> None:
        """Represents a Message Application Command that will give the message to the given callback, able to be
        registered to multiple guilds or globally.

        Parameters
        ----------
        name: :class:`str`
            Name of the command. Can be uppercase with spaces.
        name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
            Name(s) of the subcommand for users of specific locales. The locale code should be the key, with the
            localized name as the value.
        callback: :data:`~typing.Callable`
            Callback to run with the application command is called.
        guild_ids: Iterable[:class:`int`]
            An iterable list of guild ID's that the application command should register to.
        dm_permission: :class:`bool`
            If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
            usable in DMs. Only for global commands, but will not error on guild.
        default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
            Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
            example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
            default. Server owners CAN override the permission requirements.
        nsfw: :class:`bool`
            Whether the command can only be used in age-restricted channels. Defaults to ``False``.

            .. versionadded:: 2.4
        parent_cog: Optional[:class:`ClientCog`]
            ``ClientCog`` to forward to the callback as the ``self`` argument.
        force_global: :class:`bool`
            If this command should be registered as a global command, ALONG WITH all guild IDs set.
        """
        ...
    
    @property
    def description(self) -> str:
        ...
    
    @description.setter
    def description(self, new_desc: str):
        ...
    
    async def call(self, state: ConnectionState, interaction: Interaction) -> None:
        ...
    
    def from_callback(self, callback: Optional[Callable] = ..., option_class: Optional[Type[BaseCommandOption]] = ...) -> None:
        ...
    


def slash_command(name: Optional[str] = ..., description: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., description_localizations: Optional[Dict[Union[Locale, str], str]] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., force_global: bool = ...): # -> (func: (...) -> Unknown) -> SlashApplicationCommand:
    """Creates a Slash application command from the decorated function.
    Used inside :class:`ClientCog`'s or something that subclasses it.

    Parameters
    ----------
    name: :class:`str`
        Name of the command that users will see. If not set, it defaults to the name of the callback.
    description: :class:`str`
        Description of the command that users will see. If not specified, the docstring will be used.
        If no docstring is found for the command callback, it defaults to "No description provided".
    name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Name(s) of the command for users of specific locales. The locale code should be the key, with the localized
        name as the value.
    description_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Description(s) of the subcommand for users of specific locales. The locale code should be the key, with the
        localized description as the value.
    guild_ids: Optional[Iterable[:class:`int`]]
        IDs of :class:`Guild`'s to add this command to. If not passed and :attr:`Client.default_guild_ids` is
        set, then those default guild ids will be used instead. If both of those are unset, then the command will
        be a global command.
    dm_permission: :class:`bool`
        If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
        usable in DMs. Only for global commands, but will not error on guild.
    default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
        Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
        example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
        default. Server owners CAN override the permission requirements.
    nsfw: :class:`bool`
        Whether the command can only be used in age-restricted channels. Defaults to ``False``.

        .. note::

            Due to a discord limitation, this can only be set for the parent command in case of a subcommand.

        .. versionadded:: 2.4
    force_global: :class:`bool`
        If True, will force this command to register as a global command, even if ``guild_ids`` is set. Will still
        register to guilds. Has no effect if ``guild_ids`` are never set or added to.
    """
    ...

def message_command(name: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., force_global: bool = ...): # -> (func: (...) -> Unknown) -> MessageApplicationCommand:
    """Creates a Message context command from the decorated function.
    Used inside :class:`ClientCog`'s or something that subclasses it.

    Parameters
    ----------
    name: :class:`str`
        Name of the command that users will see. If not set, it defaults to the name of the callback.
    name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Name(s) of the command for users of specific locales. The locale code should be the key, with the localized
        name as the value
    guild_ids: Optional[Iterable[:class:`int`]]
        IDs of :class:`Guild`'s to add this command to. If not passed and :attr:`Client.default_guild_ids` is
        set, then those default guild ids will be used instead. If both of those are unset, then the command will
        be a global command.
    dm_permission: :class:`bool`
        If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
        usable in DMs. Only for global commands, but will not error on guild.
    default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
        Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
        example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
        default. Server owners CAN override the permission requirements.
    nsfw: :class:`bool`
        Whether the command can only be used in age-restricted channels. Defaults to ``False``.

        .. versionadded:: 2.4
    force_global: :class:`bool`
        If True, will force this command to register as a global command, even if ``guild_ids`` is set. Will still
        register to guilds. Has no effect if ``guild_ids`` are never set or added to.
    """
    ...

def user_command(name: Optional[str] = ..., *, name_localizations: Optional[Dict[Union[Locale, str], str]] = ..., guild_ids: Optional[Iterable[int]] = ..., dm_permission: Optional[bool] = ..., default_member_permissions: Optional[Union[Permissions, int]] = ..., nsfw: bool = ..., force_global: bool = ...): # -> (func: (...) -> Unknown) -> UserApplicationCommand:
    """Creates a User context command from the decorated function.
    Used inside :class:`ClientCog`'s or something that subclasses it.

    Parameters
    ----------
    name: :class:`str`
        Name of the command that users will see. If not set, it defaults to the name of the callback.
    name_localizations: Dict[Union[:class:`Locale`, :class:`str`], :class:`str`]
        Name(s) of the command for users of specific locales. The locale code should be the key, with the localized
        name as the value
    guild_ids: Optional[Iterable[:class:`int`]]
        IDs of :class:`Guild`'s to add this command to. If not passed and :attr:`Client.default_guild_ids` is
        set, then those default guild ids will be used instead. If both of those are unset, then the command will
        be a global command.
    dm_permission: :class:`bool`
        If the command should be usable in DMs or not. Setting to ``False`` will disable the command from being
        usable in DMs. Only for global commands, but will not error on guild.
    default_member_permissions: Optional[Union[:class:`Permissions`, :class:`int`]]
        Permission(s) required to use the command. Inputting ``8`` or ``Permissions(administrator=True)`` for
        example will only allow Administrators to use the command. If set to 0, nobody will be able to use it by
        default. Server owners CAN override the permission requirements.
    nsfw: :class:`bool`
        Whether the command can only be used in age-restricted channels. Defaults to ``False``.

        .. versionadded:: 2.4
    force_global: :class:`bool`
        If True, will force this command to register as a global command, even if ``guild_ids`` is set. Will still
        register to guilds. Has no effect if ``guild_ids`` are never set or added to.
    """
    ...

def check_dictionary_values(dict1: dict, dict2: dict, *keywords) -> bool:
    """Helper function to quickly check if 2 dictionaries share the equal value for the same keyword(s).
    Used primarily for checking against the registered command data from Discord.

    Will not work great if values inside the dictionary can be or are None.
    If both dictionaries lack the keyword(s), it can still return True.

    Parameters
    ----------
    dict1: :class:`dict`
        First dictionary to compare.
    dict2: :class:`dict`
        Second dictionary to compare.
    keywords: :class:`str`
        Words to compare both dictionaries to.

    Returns
    -------
    :class:`bool`
        True if keyword values in both dictionaries match, False otherwise.
    """
    ...

def deep_dictionary_check(dict1: dict, dict2: dict) -> bool:
    """Used to check if all keys and values between two dicts are equal, and recurses if it encounters a nested dict."""
    ...

def get_users_from_interaction(state: ConnectionState, interaction: Interaction) -> List[Union[User, Member]]:
    """Tries to get a list of resolved :class:`User` objects from the interaction data.

    If possible, it will get resolved :class:`Member` objects instead.

    Parameters
    ----------
    state: :class:`ConnectionState`
        State object to construct members with.
    interaction: :class:`Interaction`
        Interaction object to attempt to get users/members from.

    Returns
    -------
    List[Union[:class:`User`, :class:`Member`]]
        List of resolved users, or members if possible
    """
    ...

def get_messages_from_interaction(state: ConnectionState, interaction: Interaction) -> List[Message]:
    """Tries to get a list of resolved :class:`Message` objects from the interaction data.

    Parameters
    ----------
    state: :class:`ConnectionState`
        State object to construct messages with.
    interaction: :class:`Interaction`
        Interaction object to attempt to get resolved messages from.

    Returns
    -------
    List[:class:`Message`]
        A list of resolved messages.
    """
    ...

def get_roles_from_interaction(state: ConnectionState, interaction: Interaction) -> List[Role]:
    """Tries to get a list of resolved :class:`Role` objects from the interaction .data

    Parameters
    ----------
    state: :class:`ConnectionState`
        State object to construct roles with.
    interaction: :class:`Interaction`
        Interaction object to attempt to get resolved roles from.

    Returns
    -------
    List[:class:`Role`]
        A list of resolved roles.
    """
    ...

def unpack_annotated(given_annotation: Any, resolve_list: list[type] = ...) -> type:
    """Takes an annotation. If the origin is Annotated, it will attempt to resolve it using the given list of accepted
    types, going from the last type and working up to the first. If no matches to the given list is found, the last
    type specified in the Annotated typehint will be returned.

    If the origin is not Annotated, the typehint will be returned as-is.

    Parameters
    ----------
    given_annotation
        Annotation to attempt to resolve.
    resolve_list
        List of types the annotation can resolve to.

    Returns
    -------
    :class:`type`
        Resolved annotation.
    """
    ...

def unpack_annotation(given_annotation: Any, annotated_list: List[type] = ...) -> Tuple[List[type], list]:
    """Unpacks the given parameter annotation into its components.

    Parameters
    ----------
    given_annotation: Any
        Given annotation to unpack. Should be from ``parameter.annotation``
    annotated_list: List[:class:`type`]
        List that the ``Annotated`` annotation should attempt to resolve to, from the 2nd arg to the right.

    Returns
    -------
    Tuple[List[:class:`type`], :class:`list`]
        A list of unpacked type annotations,
        and a list of unpacked literal arguments.

    """
    ...

class RangeMeta(type):
    @overload
    def __getitem__(cls, value: Union[int, Tuple[int, int], Tuple[int, EllipsisType], Tuple[EllipsisType, int],]) -> Type[int]:
        ...
    
    @overload
    def __getitem__(cls, value: Union[float, Tuple[float, float], Tuple[float, EllipsisType], Tuple[EllipsisType, float],]) -> Type[float]:
        ...
    
    def __getitem__(cls, value: Union[int, float, Tuple[int, int], Tuple[float, float], Tuple[Union[int, float], EllipsisType], Tuple[EllipsisType, Union[int, float]],]) -> Type[Union[int, float]]:
        class Inner(Range, OptionConverter):
            ...
        
        
    


class Range(metaclass=RangeMeta):
    """An annotation helper for defining slash command ``min_value`` and ``max_value`` parameters.

    .. versionadded:: 2.2

    .. container:: operations

        .. describe:: Range[x, y]

            Creates a range from ``x`` to ``y``.

        .. describe:: Range[x] | Range[..., x]

            Create a range up to ``x``.

        .. describe:: Range[x, ...]

            Create a range from ``x``.
    """
    min: ClassVar[Optional[Union[int, float]]]
    max: ClassVar[Optional[Union[int, float]]]
    ...


class StringMeta(type):
    def __getitem__(cls, value: Union[int, Tuple[int, int], Tuple[int, EllipsisType], Tuple[EllipsisType, int],]) -> Type[str]:
        class Inner(String, OptionConverter):
            ...
        
        
    


class String(metaclass=StringMeta):
    """An annotation helper for defining slash command ``min_length`` and ``max_length`` parameters.

    .. versionadded:: 2.2

    .. container:: operations

        .. describe:: String[x, y]

            Creates a range of string length from ``x`` to ``y``.

        .. describe:: String[x] | String[..., x]

            Create a range of string length up to ``x``.

        .. describe:: String[x, ...]

            Create a range of string length from ``x``.
    """
    min: ClassVar[Optional[int]]
    max: ClassVar[Optional[int]]
    ...


