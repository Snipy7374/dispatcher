"""
This type stub file was generated by pyright.
"""

from typing import List, Optional, TYPE_CHECKING
from .enums import AutoModerationActionType, AutoModerationEventType, KeywordPresetType
from .mixins import Hashable
from .abc import Snowflake
from .state import ConnectionState
from .types.auto_moderation import AutoModerationAction as AutoModerationActionPayload, AutoModerationActionExecution as ActionExecutionPayload, AutoModerationActionMetadata as ActionMetadataPayload, AutoModerationRule as AutoModerationRulePayload, AutoModerationTriggerMetadata as TriggerMetadataPayload

if TYPE_CHECKING:
    ...
__all__ = ("AutoModerationTriggerMetadata", "AutoModerationActionMetadata", "AutoModerationAction", "AutoModerationRule", "AutoModerationActionExecution")
class AutoModerationTriggerMetadata:
    """Represents data about an auto moderation trigger rule.

    .. versionadded:: 2.1

    Attributes
    ----------
    keyword_filter: List[:class:`str`]
        A list of substrings which will be searched for in content.

        .. note::

            This is ``None`` and cannot be provided if the trigger type of the rule is not
            :attr:`AutoModerationTriggerType.keyword`.
    regex_patterns: Optional[List[:class:`str`]]
        A list of regex patterns which will be matched with content. Can only be up to 10 patterns.

        .. versionadded:: 2.4

        .. note::

            This is ``None`` and cannot be provided if the trigger type of the rule is not
            :attr:`AutoModerationTriggerType.keyword`.

        .. warning::

            The flavor of regex used is Rust flavor and has no guarantees of working with
            the :mod:`re` module.
            Each regex pattern must be 75 characters or less.

    presets: List[:class:`KeywordPresetType`]
        A list of Discord pre-defined wordsets which will be searched for in content.

        .. note::

            This is ``None`` and cannot be provided if the trigger type of the rule is not
            :attr:`AutoModerationTriggerType.keyword_preset`.
    allow_list: List[:class:`str`]
        A list of exempt strings that will not trigger the preset type.

        .. note::

            This is ``None`` and cannot be provided if the trigger type of the rule is not
            :attr:`AutoModerationTriggerType.keyword_preset`.

        .. warning::

            Wildcard syntax (`*`) is not supported here.
    mention_total_limit: Optional[:class:`int`]
        The maximum amount of mentions allowed in a messsage.

        .. versionadded:: 2.3

        .. note::

            This is ``None`` and cannot be provided if the trigger type of this rule is not :attr:`AutoModerationTriggerType.mention_spam`.
    """
    __slots__ = ...
    def __init__(self, *, keyword_filter: Optional[List[str]] = ..., regex_patterns: Optional[List[str]] = ..., presets: Optional[List[KeywordPresetType]] = ..., allow_list: Optional[List[str]] = ..., mention_total_limit: Optional[int] = ...) -> None:
        ...
    
    @classmethod
    def from_data(cls, data: TriggerMetadataPayload): # -> Self@AutoModerationTriggerMetadata:
        ...
    
    @property
    def payload(self) -> TriggerMetadataPayload:
        ...
    


class AutoModerationActionMetadata:
    """Represents additional data that is used when an action is executed.

    .. versionadded:: 2.1

    Attributes
    ----------
    channel: Optional[:class:`abc.Snowflake`]
        The channel to which message content should be logged.

        .. note::

            This is ``None`` and cannot be provided if the action type of the rule is not
            :attr:`AutoModerationActionType.send_alert_message`.
    duration_seconds: Optional[:class:`int`]
        The duration of the timeout in seconds.

        .. note::

            This is ``None`` and cannot be provided if the action type of the rule is not
            :attr:`AutoModerationActionType.timeout`.

        .. note::

            The maximum value that can be used is ``2419200`` seconds (4 weeks)
    """
    __slots__ = ...
    def __init__(self, *, channel: Optional[Snowflake] = ..., duration_seconds: Optional[int] = ...) -> None:
        ...
    
    @classmethod
    def from_data(cls, data: ActionMetadataPayload): # -> Self@AutoModerationActionMetadata:
        ...
    
    @property
    def payload(self) -> ActionMetadataPayload:
        ...
    


class AutoModerationAction:
    """Represents an auto moderation action that will execute whenever a rule is triggered.

    .. versionadded:: 2.1

    Parameters
    ----------
    type: :class:`AutoModerationActionType`
        The type to use for this action.
    metadata: :class:`AutoModerationActionMetadata`
        The additional data to use during execution of this action.

    Attributes
    ----------
    type: :class:`AutoModerationActionType`
        The type of this action.
    metadata: :class:`AutoModerationActionMetadata`
        The additional metadata needed during execution for this specific action type.
    """
    __slots__ = ...
    def __init__(self, *, type: AutoModerationActionType, metadata: Optional[AutoModerationActionMetadata] = ...) -> None:
        ...
    
    @classmethod
    def from_data(cls, data: AutoModerationActionPayload) -> AutoModerationAction:
        ...
    
    @property
    def payload(self) -> AutoModerationActionPayload:
        ...
    


class AutoModerationRule(Hashable):
    """Represents a Discord auto moderation rule.

    .. versionadded:: 2.1

    .. container:: operations

        .. describe:: x == y

            Checks if two rules are equal.

        .. describe:: x != y

            Checks if two rules are not equal.

        .. describe:: hash(x)

            Returns the rules's hash.

        .. describe:: str(x)

            Returns the rules's name.

    Attributes
    ----------
    id: :class:`int`
        The rule's unique ID.
    guild_id: :class:`int`
        The guild's unique ID which this rule belongs to.
    guild: Optional[:class:`Guild`]
        The guild which this rule belongs to, if found in cache.
    name: :class:`str`
        The rule's name.
    creator_id: :class:`int`
        The user's unique ID which first created this rule.
    creator: Optional[:class:`Member`]
        The member which first created this rule, if found in cache.
    event_type: :class:`AutoModerationEventType`
        The event context in which this rule is checked.
    trigger_type: :class:`AutoModerationTriggerType`
        The type of content that can trigger this rule.
    trigger_metadata: :class:`AutoModerationTriggerMetadata`
        Additional data that is used when checking if this rule is triggered.
    actions: List[:class:`AutoModerationAction`]
        The actions which will execute when the rule is triggered.
    enabled: :class:`bool`
        Whether the rule is enabled.
    exempt_role_ids: List[:class:`int`]
        The role ids that should not be affected by the rule.
    exempt_channel_ids: List[:class:`int`]
        The channel ids that should not be affected by the rule.
    exempt_roles: List[:class:`Role`]
        The roles that should not be affected by the rule, if found in cache.
    exempt_channels: List[:class:`abc.GuildChannel`]
        The channels that should not be affected by the rule, if found in cache.
    """
    __slots__ = ...
    def __init__(self, *, data: AutoModerationRulePayload, state: ConnectionState) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    async def delete(self, *, reason: Optional[str] = ...) -> None:
        """|coro|

        Delete the current rule from its guild.

        Requires the :attr:`~Permissions.manage_guild` permission.

        Parameters
        ----------
        reason: Optional[:class:`str`]
            The reason for deleting this rule. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have permission to delete this rule.
        HTTPException
            Deleting the rule failed.
        """
        ...
    
    async def edit(self, *, name: str = ..., event_type: AutoModerationEventType = ..., trigger_metadata: AutoModerationTriggerMetadata = ..., actions: List[AutoModerationAction] = ..., enabled: bool = ..., exempt_roles: List[Snowflake] = ..., exempt_channels: List[Snowflake] = ..., reason: Optional[str] = ...) -> AutoModerationRule:
        """Modify the current auto moderation rule.

        Requires the :attr:`~Permissions.manage_guild` permission.

        Parameters
        ----------
        name: :class:`str`
            The new name for this rule.
        event_type: :class:`AutoModerationEventType`
            The new event context in which this rule is checked.
        trigger_metadata: :class:`AutoModerationTriggerMetadata`
            The new additional data that is used when checking if this rule is triggered.
        actions: List[:class:`AutoModerationAction`]
            The new actions which will execute when the rule is triggered.
        enabled: :class:`bool`
            Whether the rule is enabled.
        exempt_roles: List[:class:`abc.Snowflake`]
            The new roles that should not be affected by the rule.
        exempt_channels: List[:class:`abc.Snowflake`]
            The new channels that should not be affected by the rule.
        reason: Optional[:class:`str`]
            The reason for editing this rule. Shows in the audit log.

        Raises
        ------
        Forbidden
            You do not have permission to edit this rule.
        HTTPException
            Editing the rule failed.
        InvalidArgument
            An incorrect type was passed.

        Returns
        -------
        :class:`AutoModerationRule`
            The newly edited auto moderation rule.
        """
        ...
    


class AutoModerationActionExecution:
    """Represents the execution of an auto moderation action

    .. versionadded:: 2.1

    Attributes
    ----------
    guild_id: :class:`int`
        The guild ID where this action was executed.
    guild: Optional[:class:`Guild`]
        The guild where this action was executed, if it was found in cache.
    channel_id: Optional[:class:`int`]
        The channel ID where this action was executed, if applicable.
    channel: Optional[:class:`abc.GuildChannel`]
        The channel where this action was executed, if applicable and found in cache.
    message_id: Optional[:class:`int`]
        The message ID that executed this action, if it was not blocked.
    message: Optional[:class:`Message`]
        The message that executed this action, if it was not blocked and found in cache.
    alert_system_message_id: Optional[:class:`int`]
        The ID of the system alert message, if sent.
    alert_system_message: Optional[:class:`Message`]
        The system alert message, if sent and found in cache.
    action: :class:`AutoModerationAction`
        The action that was executed.
    rule_id: :class:`int`
        The id of the rule that was executed.
    rule_trigger_type: :class:`AutoModerationTriggerType`
        The type of rule that was executed.
    member_id: :class:`int`
        The ID of the user that triggered this action.
    member: Optional[:class:`Member`]
        The member that triggered this action, if found in cache.
    content: :class:`str`
        The content the user sent in the message

        .. note::

            This requires :attr:`Intents.message_content` to not be empty.
    matched_keyword: Optional[:class:`str`]
        The keyword configured in the rule that matched this message, if applicable.
    matched_content: Optional[:class:`str`]
        The content in the message that matched the keyword, if applicable.

        .. note::

            This requires :attr:`Intents.message_conrent` to not be empty.
    """
    def __init__(self, *, data: ActionExecutionPayload, state: ConnectionState) -> None:
        ...
    


