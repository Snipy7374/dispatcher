"""
This type stub file was generated by pyright.
"""

import datetime
from typing import ClassVar, Dict, List, Literal, NamedTuple, Optional, Sequence, TYPE_CHECKING, Tuple, Union, overload
from . import abc, utils
from .asset import Asset
from .auto_moderation import AutoModerationAction, AutoModerationRule, AutoModerationTriggerMetadata
from .bans import BanEntry
from .channel import CategoryChannel, ForumChannel, ForumTag, StageChannel, TextChannel, VoiceChannel
from .colour import Colour
from .emoji import Emoji
from .enums import AuditLogAction, AutoModerationEventType, AutoModerationTriggerType, ContentFilter, NotificationLevel, ScheduledEventEntityType, ScheduledEventPrivacyLevel, SortOrderType, VerificationLevel, VideoQualityMode, VoiceRegion
from .flags import SystemChannelFlags
from .integrations import Integration
from .invite import Invite
from .iterators import AuditLogIterator, BanIterator, MemberIterator, ScheduledEventIterator
from .member import Member
from .mixins import Hashable
from .partial_emoji import PartialEmoji
from .permissions import PermissionOverwrite, Permissions
from .role import Role
from .scheduled_events import EntityMetadata, ScheduledEvent
from .stage_instance import StageInstance
from .sticker import GuildSticker
from .threads import Thread
from .user import User
from .widget import Widget
from .abc import Snowflake, SnowflakeTime
from .application_command import BaseApplicationCommand
from .file import File
from .message import Attachment
from .state import ConnectionState
from .template import Template
from .types.guild import Guild as GuildPayload
from .types.integration import IntegrationType
from .types.interactions import ApplicationCommand as ApplicationCommandPayload
from .voice_client import VoiceProtocol
from .webhook import Webhook

__all__ = ("Guild", )
MISSING = utils.MISSING
if TYPE_CHECKING:
    VocalGuildChannel = Union[VoiceChannel, StageChannel]
    GuildChannel = Union[VoiceChannel, StageChannel, TextChannel, CategoryChannel, ForumChannel]
    ByCategoryItem = Tuple[Optional[CategoryChannel], List[GuildChannel]]
class _GuildLimit(NamedTuple):
    emoji: int
    stickers: int
    bitrate: float
    filesize: int
    ...


class Guild(Hashable):
    """Represents a Discord guild.

    This is referred to as a "server" in the official Discord UI.

    .. container:: operations

        .. describe:: x == y

            Checks if two guilds are equal.

        .. describe:: x != y

            Checks if two guilds are not equal.

        .. describe:: hash(x)

            Returns the guild's hash.

        .. describe:: str(x)

            Returns the guild's name.

    Attributes
    ----------
    name: :class:`str`
        The guild name.
    emojis: Tuple[:class:`Emoji`, ...]
        All emojis that the guild owns.
    stickers: Tuple[:class:`GuildSticker`, ...]
        All stickers that the guild owns.

        .. versionadded:: 2.0
    region: :class:`VoiceRegion`
        The region the guild belongs on. There is a chance that the region
        will be a :class:`str` if the value is not recognised by the enumerator.
    afk_timeout: :class:`int`
        The timeout to get sent to the AFK channel.
    afk_channel: Optional[:class:`VoiceChannel`]
        The channel that denotes the AFK channel. ``None`` if it doesn't exist.
    id: :class:`int`
        The guild's ID.
    owner_id: :class:`int`
        The guild owner's ID. Use :attr:`Guild.owner` instead.
    unavailable: :class:`bool`
        Indicates if the guild is unavailable. If this is ``True`` then the
        reliability of other attributes outside of :attr:`Guild.id` is slim and they might
        all be ``None``. It is best to not do anything with the guild if it is unavailable.

        Check the :func:`on_guild_unavailable` and :func:`on_guild_available` events.
    max_presences: Optional[:class:`int`]
        The maximum amount of presences for the guild.
    max_members: Optional[:class:`int`]
        The maximum amount of members for the guild.

        .. note::

            This attribute is only available via :meth:`.Client.fetch_guild`.
    max_video_channel_users: Optional[:class:`int`]
        The maximum amount of users in a video channel.

        .. versionadded:: 1.4
    description: Optional[:class:`str`]
        The guild's description.
    mfa_level: :class:`int`
        Indicates the guild's two factor authorisation level. If this value is 0 then
        the guild does not require 2FA for their administrative members. If the value is
        1 then they do.
    verification_level: :class:`VerificationLevel`
        The guild's verification level.
    explicit_content_filter: :class:`ContentFilter`
        The guild's explicit content filter.
    default_notifications: :class:`NotificationLevel`
        The guild's notification settings.
    features: List[:class:`str`]
        A list of features that the guild has. The features that a guild can have are
        subject to arbitrary change by Discord.

        They are currently as follows:

        - ``ANIMATED_BANNER``: Guild can upload an animated banner.
        - ``ANIMATED_ICON``: Guild can upload an animated icon.
        - ``AUTO_MODERATION``: Guild has set up auto moderation rules.
        - ``APPLICATION_COMMAND_PERMISSIONS_V2``: Guild is using the old permissions configuration behavior.
        - ``BANNER``: Guild can upload and use a banner. (i.e. :attr:`.banner`)
        - ``COMMUNITY``: Guild is a community server.
        - ``DEVELOPER_SUPPORT_SERVER``: Guild has been set as a support server on the App Directory.
        - ``DISCOVERABLE``: Guild shows up in Server Discovery.
        - ``FEATURABLE``: Guild is able to be featured in Server Discovery.
        - ``INVITES_DISABLED``: Guild has paused invites, preventing new users from joining.
        - ``INVITE_SPLASH``: Guild's invite page can have a special splash.
        - ``MEMBER_VERIFICATION_GATE_ENABLED``: Guild has Membership Screening enabled.
        - ``MONETIZATION_ENABLED``: Guild has enabled monetization.
        - ``MORE_STICKERS``: Guild has increased custom sticker slots.
        - ``NEWS``: Guild can create news channels.
        - ``PARTNERED``: Guild is a partnered server.
        - ``PREVIEW_ENABLED``: Guild can be viewed before being accepted via Membership Screening.
        - ``ROLE_ICONS``: Guild is able to set role icons.
        - ``TICKETED_EVENTS_ENABLED``: Guild has enabled ticketed events.
        - ``VANITY_URL``: Guild can have a vanity invite URL (e.g. discord.gg/discord-api).
        - ``VERIFIED``: Guild is a verified server.
        - ``VIP_REGIONS``: Guild has VIP voice regions.
        - ``WELCOME_SCREEN_ENABLED``: Guild has enabled the welcome screen.

    premium_tier: :class:`int`
        The premium tier for this guild. Corresponds to "Boost Level" in the official UI.
        The number goes from 0 to 3 inclusive.
    premium_subscription_count: :class:`int`
        The number of "boosts" this guild currently has.
    preferred_locale: Optional[:class:`str`]
        The preferred locale for the guild. Used when filtering Server Discovery
        results to a specific language.
    nsfw_level: :class:`NSFWLevel`
        The guild's NSFW level.

        .. versionadded:: 2.0

    approximate_member_count: Optional[:class:`int`]
        The approximate number of members in the guild. This is ``None`` unless the guild is obtained
        using :meth:`Client.fetch_guild` with ``with_counts=True``.

        .. versionadded:: 2.0

    approximate_presence_count: Optional[:class:`int`]
        The approximate number of members currently active in the guild.
        This includes idle, dnd, online, and invisible members. Offline members are excluded.
        This is ``None`` unless the guild is obtained using :meth:`Client.fetch_guild`
        with ``with_counts=True``.

        .. versionadded:: 2.0
    """
    __slots__ = ...
    _PREMIUM_GUILD_LIMITS: ClassVar[Dict[Optional[int], _GuildLimit]] = ...
    def __init__(self, *, data: GuildPayload, state: ConnectionState) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def channels(self) -> List[GuildChannel]:
        """List[:class:`abc.GuildChannel`]: A list of channels that belong to this guild."""
        ...
    
    @property
    def threads(self) -> List[Thread]:
        """List[:class:`Thread`]: A list of threads that you have permission to view.

        .. versionadded:: 2.0
        """
        ...
    
    @property
    def large(self) -> bool:
        """:class:`bool`: Indicates if the guild is a 'large' guild.

        A large guild is defined as having more than ``large_threshold`` count
        members, which for this library is set to the maximum of 250.
        """
        ...
    
    @property
    def invites_disabled(self) -> bool:
        """:class:`bool`: Indicates if the guild's invites are paused.

        .. versionadded:: 2.4
        """
        ...
    
    @property
    def voice_channels(self) -> List[VoiceChannel]:
        """List[:class:`VoiceChannel`]: A list of voice channels that belong to this guild.

        This is sorted by the position and are in UI order from top to bottom.
        """
        ...
    
    @property
    def stage_channels(self) -> List[StageChannel]:
        """List[:class:`StageChannel`]: A list of stage channels that belong to this guild.

        .. versionadded:: 1.7

        This is sorted by the position and are in UI order from top to bottom.
        """
        ...
    
    @property
    def me(self) -> Member:
        """:class:`Member`: Similar to :attr:`Client.user` except an instance of :class:`Member`.
        This is essentially used to get the member version of yourself.
        """
        ...
    
    @property
    def voice_client(self) -> Optional[VoiceProtocol]:
        """Optional[:class:`VoiceProtocol`]: Returns the :class:`VoiceProtocol` associated with this guild, if any."""
        ...
    
    @property
    def text_channels(self) -> List[TextChannel]:
        """List[:class:`TextChannel`]: A list of text channels that belong to this guild.

        This is sorted by the position and are in UI order from top to bottom.
        """
        ...
    
    @property
    def categories(self) -> List[CategoryChannel]:
        """List[:class:`CategoryChannel`]: A list of categories that belong to this guild.

        This is sorted by the position and are in UI order from top to bottom.
        """
        ...
    
    @property
    def forum_channels(self) -> List[ForumChannel]:
        """List[:class:`ForumChannel`]: A list of forum channels that belong to this guild.

        This is sorted by the position and are in UI order from top to bottom.
        """
        ...
    
    @property
    def scheduled_events(self) -> List[ScheduledEvent]:
        """List[:class:`ScheduledEvent`]: A list of scheduled events in this guild.

        .. versionadded:: 2.0
        """
        ...
    
    def by_category(self) -> List[ByCategoryItem]:
        """Returns every :class:`CategoryChannel` and their associated channels.

        These channels and categories are sorted in the official Discord UI order.

        If the channels do not have a category, then the first element of the tuple is
        ``None``.

        Returns
        -------
        List[Tuple[Optional[:class:`CategoryChannel`], List[:class:`abc.GuildChannel`]]]:
            The categories and their associated channels.
        """
        ...
    
    def get_channel_or_thread(self, channel_id: int, /) -> Optional[Union[Thread, GuildChannel]]:
        """Returns a channel or thread with the given ID.

        .. versionadded:: 2.0

        Parameters
        ----------
        channel_id: :class:`int`
            The ID to search for.

        Returns
        -------
        Optional[Union[:class:`Thread`, :class:`.abc.GuildChannel`]]
            The returned channel or thread or ``None`` if not found.
        """
        ...
    
    def get_channel(self, channel_id: int, /) -> Optional[GuildChannel]:
        """Returns a channel with the given ID.

        .. note::

            This does *not* search for threads.

        Parameters
        ----------
        channel_id: :class:`int`
            The ID to search for.

        Returns
        -------
        Optional[:class:`.abc.GuildChannel`]
            The returned channel or ``None`` if not found.
        """
        ...
    
    def get_thread(self, thread_id: int, /) -> Optional[Thread]:
        """Returns a thread with the given ID.

        .. versionadded:: 2.0

        Parameters
        ----------
        thread_id: :class:`int`
            The ID to search for.

        Returns
        -------
        Optional[:class:`Thread`]
            The returned thread or ``None`` if not found.
        """
        ...
    
    @property
    def system_channel(self) -> Optional[TextChannel]:
        """Optional[:class:`TextChannel`]: Returns the guild's channel used for system messages.

        If no channel is set, then this returns ``None``.
        """
        ...
    
    @property
    def system_channel_flags(self) -> SystemChannelFlags:
        """:class:`SystemChannelFlags`: Returns the guild's system channel settings."""
        ...
    
    @property
    def rules_channel(self) -> Optional[TextChannel]:
        """Optional[:class:`TextChannel`]: Return's the guild's channel used for the rules.
        The guild must be a Community guild.

        If no channel is set, then this returns ``None``.

        .. versionadded:: 1.3
        """
        ...
    
    @property
    def public_updates_channel(self) -> Optional[TextChannel]:
        """Optional[:class:`TextChannel`]: Return's the guild's channel where admins and
        moderators of the guilds receive notices from Discord. The guild must be a
        Community guild.

        If no channel is set, then this returns ``None``.

        .. versionadded:: 1.4
        """
        ...
    
    @property
    def emoji_limit(self) -> int:
        """:class:`int`: The maximum number of emoji slots this guild has."""
        ...
    
    @property
    def sticker_limit(self) -> int:
        """:class:`int`: The maximum number of sticker slots this guild has.

        .. versionadded:: 2.0
        """
        ...
    
    @property
    def bitrate_limit(self) -> float:
        """:class:`float`: The maximum bitrate for voice channels this guild can have."""
        ...
    
    @property
    def filesize_limit(self) -> int:
        """:class:`int`: The maximum number of bytes files can have when uploaded to this guild."""
        ...
    
    @property
    def members(self) -> List[Member]:
        """List[:class:`Member`]: A list of members that belong to this guild."""
        ...
    
    @property
    def bots(self) -> List[Member]:
        """List[:class:`Member`]: A list of bots that belong to this guild.

        .. warning::

            Due to a Discord limitation, in order for this attribute to remain up-to-date and
            accurate, it requires :attr:`Intents.members` to be specified.

        .. versionadded:: 2.0"""
        ...
    
    @property
    def humans(self) -> List[Member]:
        """List[:class:`Member`]: A list of user accounts that belong to this guild.

        .. warning::

            Due to a Discord limitation, in order for this attribute to remain up-to-date and
            accurate, it requires :attr:`Intents.members` to be specified.

        .. versionadded:: 2.0"""
        ...
    
    def get_member(self, user_id: int, /) -> Optional[Member]:
        """Returns a member with the given ID.

        Parameters
        ----------
        user_id: :class:`int`
            The ID to search for.

        Returns
        -------
        Optional[:class:`Member`]
            The member or ``None`` if not found.
        """
        ...
    
    @property
    def premium_subscribers(self) -> List[Member]:
        """List[:class:`Member`]: A list of members who have "boosted" this guild."""
        ...
    
    @property
    def roles(self) -> List[Role]:
        """List[:class:`Role`]: Returns a :class:`list` of the guild's roles in hierarchy order.

        The first element of this list will be the lowest role in the
        hierarchy.
        """
        ...
    
    def get_role(self, role_id: int, /) -> Optional[Role]:
        """Returns a role with the given ID.

        Parameters
        ----------
        role_id: :class:`int`
            The ID to search for.

        Returns
        -------
        Optional[:class:`Role`]
            The role or ``None`` if not found.
        """
        ...
    
    @property
    def default_role(self) -> Role:
        """:class:`Role`: Gets the @everyone role that all members have by default."""
        ...
    
    @property
    def premium_subscriber_role(self) -> Optional[Role]:
        """Optional[:class:`Role`]: Gets the premium subscriber role, AKA "boost" role, in this guild.

        .. versionadded:: 1.6
        """
        ...
    
    @property
    def self_role(self) -> Optional[Role]:
        """Optional[:class:`Role`]: Gets the role associated with this client's user, if any.

        .. versionadded:: 1.6
        """
        ...
    
    @property
    def stage_instances(self) -> List[StageInstance]:
        """List[:class:`StageInstance`]: Returns a :class:`list` of the guild's stage instances that
        are currently running.

        .. versionadded:: 2.0
        """
        ...
    
    def get_stage_instance(self, stage_instance_id: int, /) -> Optional[StageInstance]:
        """Returns a stage instance with the given ID.

        .. versionadded:: 2.0

        Parameters
        ----------
        stage_instance_id: :class:`int`
            The ID to search for.

        Returns
        -------
        Optional[:class:`StageInstance`]
            The stage instance or ``None`` if not found.
        """
        ...
    
    @property
    def owner(self) -> Optional[Member]:
        """Optional[:class:`Member`]: The member that owns the guild."""
        ...
    
    @property
    def icon(self) -> Optional[Asset]:
        """Optional[:class:`Asset`]: Returns the guild's icon asset, if available."""
        ...
    
    @property
    def banner(self) -> Optional[Asset]:
        """Optional[:class:`Asset`]: Returns the guild's banner asset, if available."""
        ...
    
    @property
    def splash(self) -> Optional[Asset]:
        """Optional[:class:`Asset`]: Returns the guild's invite splash asset, if available."""
        ...
    
    @property
    def discovery_splash(self) -> Optional[Asset]:
        """Optional[:class:`Asset`]: Returns the guild's discovery splash asset, if available."""
        ...
    
    @property
    def member_count(self) -> Optional[int]:
        """Optional[:class:`int`]: Returns the true member count, if available.

        .. warning::

            Due to a Discord limitation, in order for this attribute to remain up-to-date and
            accurate, it requires :attr:`Intents.members` to be specified.

        """
        ...
    
    @property
    def chunked(self) -> bool:
        """:class:`bool`: Returns a boolean indicating if the guild is "chunked".

        A chunked guild means that :attr:`member_count` is equal to the
        number of members stored in the internal :attr:`members` cache.

        If this value returns ``False``, then you should request for
        offline members.
        """
        ...
    
    @property
    def shard_id(self) -> int:
        """:class:`int`: Returns the shard ID for this guild if applicable."""
        ...
    
    @property
    def created_at(self) -> datetime.datetime:
        """:class:`datetime.datetime`: Returns the guild's creation time in UTC."""
        ...
    
    def get_member_named(self, name: str, /) -> Optional[Member]:
        """Returns the first member found that matches the name provided.

        The name can have an optional discriminator argument, e.g. "Jake#0001"
        or "Jake" will both do the lookup. However the former will give a more
        precise result. Note that the discriminator must have all 4 digits
        for this to work.

        If a nickname is passed, then it is looked up via the nickname. Note
        however, that a nickname + discriminator combo will not lookup the nickname
        but rather the username + discriminator combo due to nickname + discriminator
        not being unique.

        If no member is found, ``None`` is returned.

        Parameters
        ----------
        name: :class:`str`
            The name of the member to lookup with an optional discriminator.

        Returns
        -------
        Optional[:class:`Member`]
            The member in this guild with the associated name. If not found
            then ``None`` is returned.
        """
        ...
    
    async def create_text_channel(self, name: str, *, reason: Optional[str] = ..., category: Optional[CategoryChannel] = ..., position: int = ..., topic: str = ..., slowmode_delay: int = ..., nsfw: bool = ..., overwrites: Dict[Union[Role, Member], PermissionOverwrite] = ..., default_thread_slowmode_delay: int = ...) -> TextChannel:
        """|coro|

        Creates a :class:`TextChannel` for the guild.

        Note that you need the :attr:`~Permissions.manage_channels` permission
        to create the channel.

        The ``overwrites`` parameter can be used to create a 'secret'
        channel upon creation. This parameter expects a :class:`dict` of
        overwrites with the target (either a :class:`Member` or a :class:`Role`)
        as the key and a :class:`PermissionOverwrite` as the value.

        .. note::

            Creating a channel of a specified position will not update the position of
            other channels to follow suit. A follow-up call to :meth:`~TextChannel.edit`
            will be required to update the position of the channel in the channel list.

        Examples
        --------

        Creating a basic channel:

        .. code-block:: python3

            channel = await guild.create_text_channel('cool-channel')

        Creating a "secret" channel:

        .. code-block:: python3

            overwrites = {
                guild.default_role: nextcord.PermissionOverwrite(read_messages=False),
                guild.me: nextcord.PermissionOverwrite(read_messages=True)
            }

            channel = await guild.create_text_channel('secret', overwrites=overwrites)

        Parameters
        ----------
        name: :class:`str`
            The channel's name.
        overwrites: Dict[Union[:class:`Role`, :class:`Member`], :class:`PermissionOverwrite`]
            A :class:`dict` of target (either a role or a member) to
            :class:`PermissionOverwrite` to apply upon creation of a channel.
            Useful for creating secret channels.
        category: Optional[:class:`CategoryChannel`]
            The category to place the newly created channel under.
            The permissions will be automatically synced to category if no
            overwrites are provided.
        position: :class:`int`
            The position in the channel list. This is a number that starts
            at 0. e.g. the top channel is position 0.
        topic: :class:`str`
            The new channel's topic.
        slowmode_delay: :class:`int`
            Specifies the slowmode rate limit for user in this channel, in seconds.
            The maximum value possible is ``21600``.
        nsfw: :class:`bool`
            To mark the channel as NSFW or not.
        reason: Optional[:class:`str`]
            The reason for creating this channel. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to create this channel.
        HTTPException
            Creating the channel failed.
        InvalidArgument
            The permission overwrite information is not in proper form.

        Returns
        -------
        :class:`TextChannel`
            The channel that was just created.
        """
        ...
    
    async def create_voice_channel(self, name: str, *, reason: Optional[str] = ..., category: Optional[CategoryChannel] = ..., position: int = ..., bitrate: int = ..., user_limit: int = ..., rtc_region: Optional[VoiceRegion] = ..., video_quality_mode: VideoQualityMode = ..., overwrites: Dict[Union[Role, Member], PermissionOverwrite] = ...) -> VoiceChannel:
        """|coro|

        This is similar to :meth:`create_text_channel` except makes a :class:`VoiceChannel` instead.

        Parameters
        ----------
        name: :class:`str`
            The channel's name.
        overwrites: Dict[Union[:class:`Role`, :class:`Member`], :class:`PermissionOverwrite`]
            A :class:`dict` of target (either a role or a member) to
            :class:`PermissionOverwrite` to apply upon creation of a channel.
            Useful for creating secret channels.
        category: Optional[:class:`CategoryChannel`]
            The category to place the newly created channel under.
            The permissions will be automatically synced to category if no
            overwrites are provided.
        position: :class:`int`
            The position in the channel list. This is a number that starts
            at 0. e.g. the top channel is position 0.
        bitrate: :class:`int`
            The channel's preferred audio bitrate in bits per second.
        user_limit: :class:`int`
            The channel's limit for number of members that can be in a voice channel.
        rtc_region: Optional[:class:`VoiceRegion`]
            The region for the voice channel's voice communication.
            A value of ``None`` indicates automatic voice region detection.

            .. versionadded:: 1.7
        video_quality_mode: :class:`VideoQualityMode`
            The camera video quality for the voice channel's participants.

            .. versionadded:: 2.0
        reason: Optional[:class:`str`]
            The reason for creating this channel. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to create this channel.
        HTTPException
            Creating the channel failed.
        InvalidArgument
            The permission overwrite information is not in proper form.

        Returns
        -------
        :class:`VoiceChannel`
            The channel that was just created.
        """
        ...
    
    async def create_stage_channel(self, name: str, *, topic: str, position: int = ..., overwrites: Dict[Union[Role, Member], PermissionOverwrite] = ..., category: Optional[CategoryChannel] = ..., reason: Optional[str] = ...) -> StageChannel:
        """|coro|

        This is similar to :meth:`create_text_channel` except makes a :class:`StageChannel` instead.

        .. versionadded:: 1.7

        Parameters
        ----------
        name: :class:`str`
            The channel's name.
        topic: :class:`str`
            The new channel's topic.
        overwrites: Dict[Union[:class:`Role`, :class:`Member`], :class:`PermissionOverwrite`]
            A :class:`dict` of target (either a role or a member) to
            :class:`PermissionOverwrite` to apply upon creation of a channel.
            Useful for creating secret channels.
        category: Optional[:class:`CategoryChannel`]
            The category to place the newly created channel under.
            The permissions will be automatically synced to category if no
            overwrites are provided.
        position: :class:`int`
            The position in the channel list. This is a number that starts
            at 0. e.g. the top channel is position 0.
        reason: Optional[:class:`str`]
            The reason for creating this channel. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to create this channel.
        HTTPException
            Creating the channel failed.
        InvalidArgument
            The permission overwrite information is not in proper form.

        Returns
        -------
        :class:`StageChannel`
            The channel that was just created.
        """
        ...
    
    async def create_category(self, name: str, *, overwrites: Dict[Union[Role, Member], PermissionOverwrite] = ..., reason: Optional[str] = ..., position: int = ...) -> CategoryChannel:
        """|coro|

        Same as :meth:`create_text_channel` except makes a :class:`CategoryChannel` instead.

        .. note::

            The ``category`` parameter is not supported in this function since categories
            cannot have categories.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to create this channel.
        HTTPException
            Creating the channel failed.
        InvalidArgument
            The permission overwrite information is not in proper form.

        Returns
        -------
        :class:`CategoryChannel`
            The channel that was just created.
        """
        ...
    
    async def create_forum_channel(self, name: str, *, topic: str, position: int = ..., overwrites: Dict[Union[Role, Member], PermissionOverwrite] = ..., category: Optional[CategoryChannel] = ..., default_thread_slowmode_delay: int = ..., default_reaction: Optional[Union[Emoji, PartialEmoji, str]] = ..., available_tags: List[ForumTag] = ..., reason: Optional[str] = ..., default_sort_order: SortOrderType = ...) -> ForumChannel:
        """|coro|

        This is similar to :meth:`create_text_channel` except makes a :class:`ForumChannel` instead.

        .. versionadded:: 2.1

        Parameters
        ----------
        name: :class:`str`
            The channel's name.
        topic: :class:`str`
            The new channel's topic.
        overwrites: Dict[Union[:class:`Role`, :class:`Member`], :class:`PermissionOverwrite`]
            A :class:`dict` of target (either a role or a member) to
            :class:`PermissionOverwrite` to apply upon creation of a channel.
            Useful for creating secret channels.
        category: Optional[:class:`CategoryChannel`]
            The category to place the newly created channel under.
            The permissions will be automatically synced to category if no
            overwrites are provided.
        position: :class:`int`
            The position in the channel list. This is a number that starts
            at 0. e.g. the top channel is position 0.
        reason: Optional[:class:`str`]
            The reason for creating this channel. Shows up on the audit log.
        default_sort_order: Optional[:class:`SortOrderType`]
            The default sort order used to sort posts in this channel.

            .. versionadded:: 2.3
        default_thread_slowmode_delay: :class:`int`
            The default slowmode delay for threads created in this channel.
            Must be between ``0`` and ``21600``.

            .. versionadded:: 2.4
        default_reaction: Optional[Union[:class:`Emoji`, :class:`PartialEmoji`, :class:`str`]]
            The default reaction for threads created in this channel.

            .. versionadded:: 2.4
        available_tags: List[:class:`ForumTag`]
            The available tags for threads created in this channel.

            .. versionadded:: 2.4

        Raises
        ------
        Forbidden
            You do not have the proper permissions to create this channel.
        HTTPException
            Creating the channel failed.
        InvalidArgument
            The permission overwrite information is not in proper form.

        Returns
        -------
        :class:`ForumChannel`
            The channel that was just created.
        """
        ...
    
    create_category_channel = ...
    async def leave(self) -> None:
        """|coro|

        Leaves the guild.

        .. note::

            You cannot leave the guild that you own, you must delete it instead
            via :meth:`delete`.

        Raises
        ------
        HTTPException
            Leaving the guild failed.
        """
        ...
    
    async def delete(self) -> None:
        """|coro|

        Deletes the guild. You must be the guild owner to delete the
        guild.

        Raises
        ------
        HTTPException
            Deleting the guild failed.
        Forbidden
            You do not have permissions to delete the guild.
        """
        ...
    
    async def edit(self, *, reason: Optional[str] = ..., name: str = ..., description: Optional[str] = ..., icon: Optional[Union[bytes, Asset, Attachment, File]] = ..., banner: Optional[Union[bytes, Asset, Attachment, File]] = ..., splash: Optional[Union[bytes, Asset, Attachment, File]] = ..., discovery_splash: Optional[Union[bytes, Asset, Attachment, File]] = ..., community: bool = ..., region: Optional[Union[str, VoiceRegion]] = ..., afk_channel: Optional[VoiceChannel] = ..., owner: Snowflake = ..., afk_timeout: int = ..., default_notifications: NotificationLevel = ..., verification_level: VerificationLevel = ..., explicit_content_filter: ContentFilter = ..., vanity_code: str = ..., system_channel: Optional[TextChannel] = ..., system_channel_flags: SystemChannelFlags = ..., preferred_locale: str = ..., rules_channel: Optional[TextChannel] = ..., public_updates_channel: Optional[TextChannel] = ..., invites_disabled: bool = ...) -> Guild:
        r"""|coro|

        Edits the guild.

        You must have the :attr:`~Permissions.manage_guild` permission
        to edit the guild.

        .. versionchanged:: 1.4
            The ``rules_channel`` and ``public_updates_channel`` keyword-only parameters were added.

        .. versionchanged:: 2.0
            The ``discovery_splash`` and ``community`` keyword-only parameters were added.

        .. versionchanged:: 2.0
            The newly updated guild is returned.

        .. versionchanged:: 2.1
            The ``icon``, ``banner``, ``splash``, ``discovery_splash``
            parameters now accept :class:`File`, :class:`Attachment`, and :class:`Asset`.

        .. versionchanged:: 2.4
            The ``invites_disabled`` parameter has been added.

        Parameters
        ----------
        name: :class:`str`
            The new name of the guild.
        description: Optional[:class:`str`]
            The new description of the guild. Could be ``None`` for no description.
            This is only available to guilds that contain ``PUBLIC`` in :attr:`Guild.features`.
        icon: Optional[Union[:class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]]
            A :term:`py:bytes-like object`, :class:`File`, :class:`Attachment`, or :class:`Asset`
            representing the icon. Only PNG/JPEG is supported. GIF is only available to guilds that contain
            ``ANIMATED_ICON`` in :attr:`Guild.features`. Could be ``None`` to denote removal of the icon.
        banner: Optional[Union[:class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]]
            A :term:`py:bytes-like object`, :class:`File`, :class:`Attachment`, or :class:`Asset`
            representing the banner. Could be ``None`` to denote removal of the banner.
            This is only available to guilds that contain ``BANNER`` in :attr:`Guild.features`.
        splash: Optional[Union[:class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]]
            A :term:`py:bytes-like object`, :class:`File`, :class:`Attachment`, or :class:`Asset`
            representing the invite splash. Only PNG/JPEG supported. Could be ``None`` to denote removing the
            splash. This is only available to guilds that contain ``INVITE_SPLASH`` in :attr:`Guild.features`.
        discovery_splash: Optional[Union[:class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]]
            A :term:`py:bytes-like object`, :class:`File`, :class:`Attachment`, or :class:`Asset`
            representing the discovery splash. Only PNG/JPEG supported. Could be ``None`` to denote removing the
            splash. This is only available to guilds that contain ``DISCOVERABLE`` in :attr:`Guild.features`.
        community: :class:`bool`
            Whether the guild should be a Community guild. If set to ``True``\, both ``rules_channel``
            and ``public_updates_channel`` parameters are required.
        region: Union[:class:`str`, :class:`VoiceRegion`]
            The new region for the guild's voice communication.
        afk_channel: Optional[:class:`VoiceChannel`]
            The new channel that is the AFK channel. Could be ``None`` for no AFK channel.
        afk_timeout: :class:`int`
            The number of seconds until someone is moved to the AFK channel.
        owner: :class:`Member`
            The new owner of the guild to transfer ownership to. Note that you must
            be owner of the guild to do this.
        verification_level: :class:`VerificationLevel`
            The new verification level for the guild.
        default_notifications: :class:`NotificationLevel`
            The new default notification level for the guild.
        explicit_content_filter: :class:`ContentFilter`
            The new explicit content filter for the guild.
        vanity_code: :class:`str`
            The new vanity code for the guild.
        system_channel: Optional[:class:`TextChannel`]
            The new channel that is used for the system channel. Could be ``None`` for no system channel.
        system_channel_flags: :class:`SystemChannelFlags`
            The new system channel settings to use with the new system channel.
        preferred_locale: :class:`str`
            The new preferred locale for the guild. Used as the primary language in the guild.
            If set, this must be an ISO 639 code, e.g. ``en-US`` or ``ja`` or ``zh-CN``.
        rules_channel: Optional[:class:`TextChannel`]
            The new channel that is used for rules. This is only available to
            guilds that contain ``PUBLIC`` in :attr:`Guild.features`. Could be ``None`` for no rules
            channel.
        public_updates_channel: Optional[:class:`TextChannel`]
            The new channel that is used for public updates from Discord. This is only available to
            guilds that contain ``PUBLIC`` in :attr:`Guild.features`. Could be ``None`` for no
            public updates channel.
        invites_disabled: :class:`bool`
            Whether the invites should be paused for the guild.
            This will prevent new users from joining said guild.

            .. versionadded:: 2.4
        reason: Optional[:class:`str`]
            The reason for editing this guild. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have permissions to edit the guild.
        HTTPException
            Editing the guild failed.
        InvalidArgument
            The image format passed in to ``icon`` is invalid. It must be
            PNG or JPG. This is also raised if you are not the owner of the
            guild and request an ownership transfer.

        Returns
        -------
        :class:`Guild`
            The newly updated guild. Note that this has the same limitations as
            mentioned in :meth:`Client.fetch_guild` and may not have full data.
        """
        ...
    
    async def fetch_channels(self) -> Sequence[GuildChannel]:
        """|coro|

        Retrieves all :class:`abc.GuildChannel` that the guild has.

        .. note::

            This method is an API call. For general usage, consider :attr:`channels` instead.

        .. versionadded:: 1.2

        Raises
        ------
        InvalidData
            An unknown channel type was received from Discord.
        HTTPException
            Retrieving the channels failed.

        Returns
        -------
        Sequence[:class:`abc.GuildChannel`]
            All channels in the guild.
        """
        ...
    
    async def active_threads(self) -> List[Thread]:
        """|coro|

        Returns a list of active :class:`Thread` that the client can access.

        This includes both private and public threads.

        .. versionadded:: 2.0

        Raises
        ------
        HTTPException
            The request to get the active threads failed.

        Returns
        -------
        List[:class:`Thread`]
            The active threads
        """
        ...
    
    def fetch_members(self, *, limit: Optional[int] = ..., after: Optional[SnowflakeTime] = ...) -> MemberIterator:
        """Retrieves an :class:`.AsyncIterator` that enables receiving the guild's members. In order to use this,
        :meth:`Intents.members` must be enabled.

        .. note::

            This method is an API call. For general usage, consider :attr:`members` instead.

        .. versionadded:: 1.3

        All parameters are optional.

        Parameters
        ----------
        limit: Optional[:class:`int`]
            The number of members to retrieve. Defaults to 1000.
            Pass ``None`` to fetch all members. Note that this is potentially slow.
        after: Optional[Union[:class:`.abc.Snowflake`, :class:`datetime.datetime`]]
            Retrieve members after this date or object.
            If a datetime is provided, it is recommended to use a UTC aware datetime.
            If the datetime is naive, it is assumed to be local time.

        Raises
        ------
        ClientException
            The members intent is not enabled.
        HTTPException
            Getting the members failed.

        Yields
        ------
        :class:`.Member`
            The member with the member data parsed.

        Examples
        --------

        Usage ::

            async for member in guild.fetch_members(limit=150):
                print(member.name)

        Flattening into a list ::

            members = await guild.fetch_members(limit=150).flatten()
            # members is now a list of Member...
        """
        ...
    
    async def fetch_member(self, member_id: int, /) -> Member:
        """|coro|

        Retrieves a :class:`Member` from a guild ID, and a member ID.

        .. note::

            This method is an API call. If you have :attr:`Intents.members` and member cache enabled, consider :meth:`get_member` instead.

        Parameters
        ----------
        member_id: :class:`int`
            The member's ID to fetch from.

        Raises
        ------
        Forbidden
            You do not have access to the guild.
        HTTPException
            Fetching the member failed.

        Returns
        -------
        :class:`Member`
            The member from the member ID.
        """
        ...
    
    async def fetch_ban(self, user: Snowflake) -> BanEntry:
        """|coro|

        Retrieves the :class:`BanEntry` for a user.

        You must have the :attr:`~Permissions.ban_members` permission
        to get this information.

        Parameters
        ----------
        user: :class:`abc.Snowflake`
            The user to get ban information from.

        Raises
        ------
        Forbidden
            You do not have proper permissions to get the information.
        NotFound
            This user is not banned.
        HTTPException
            An error occurred while fetching the information.

        Returns
        -------
        :class:`BanEntry`
            The :class:`BanEntry` object for the specified user.
        """
        ...
    
    async def fetch_channel(self, channel_id: int, /) -> Union[GuildChannel, Thread]:
        """|coro|

        Retrieves a :class:`.abc.GuildChannel` or :class:`.Thread` with the specified ID.

        .. note::

            This method is an API call. For general usage, consider :meth:`get_channel_or_thread` instead.

        .. versionadded:: 2.0

        Raises
        ------
        :exc:`.InvalidData`
            An unknown channel type was received from Discord
            or the guild the channel belongs to is not the same
            as the one in this object points to.
        :exc:`.HTTPException`
            Retrieving the channel failed.
        :exc:`.NotFound`
            Invalid Channel ID.
        :exc:`.Forbidden`
            You do not have permission to fetch this channel.

        Returns
        -------
        Union[:class:`.abc.GuildChannel`, :class:`.Thread`]
            The channel from the ID.
        """
        ...
    
    def bans(self, *, limit: Optional[int] = ..., before: Optional[Snowflake] = ..., after: Optional[Snowflake] = ...) -> BanIterator:
        """Returns an :class:`~nextcord.AsyncIterator` that enables receiving the destination's bans.

        You must have the :attr:`~Permissions.ban_members` permission to get this information.

        .. versionchanged:: 2.0
            Due to a breaking change in Discord's API, this now returns an :class:`~nextcord.AsyncIterator` instead of a :class:`list`.

        Examples
        --------

        Usage ::

            counter = 0
            async for ban in guild.bans(limit=200):
                if not ban.user.bot:
                    counter += 1

        Flattening into a list: ::

            bans = await guild.bans(limit=123).flatten()
            # bans is now a list of BanEntry...

        All parameters are optional.

        Parameters
        ----------
        limit: Optional[:class:`int`]
            The number of bans to retrieve.
            If ``None``, it retrieves every ban in the guild. Note, however,
            that this would make a slow operation.
            Defaults to 1000.
        before: Optional[:class:`~nextcord.abc.Snowflake`]
            Retrieve bans before this user.
        after: Optional[:class:`~nextcord.abc.Snowflake`]
            Retrieve bans after this user.

        Raises
        ------
        ~nextcord.Forbidden
            You do not have permissions to get the bans.
        ~nextcord.HTTPException
            An error occurred while fetching the bans.

        Yields
        ------
        :class:`~nextcord.BanEntry`
            The ban with the ban data parsed.
        """
        ...
    
    async def prune_members(self, *, days: int, compute_prune_count: bool = ..., roles: List[Snowflake] = ..., reason: Optional[str] = ...) -> Optional[int]:
        r"""|coro|

        Prunes the guild from its inactive members.

        The inactive members are denoted if they have not logged on in
        ``days`` number of days and they have no roles.

        You must have the :attr:`~Permissions.kick_members` permission
        to use this.

        To check how many members you would prune without actually pruning,
        see the :meth:`estimate_pruned_members` function.

        To prune members that have specific roles see the ``roles`` parameter.

        .. versionchanged:: 1.4
            The ``roles`` keyword-only parameter was added.

        Parameters
        ----------
        days: :class:`int`
            The number of days before counting as inactive.
        reason: Optional[:class:`str`]
            The reason for doing this action. Shows up on the audit log.
        compute_prune_count: :class:`bool`
            Whether to compute the prune count. This defaults to ``True``
            which makes it prone to timeouts in very large guilds. In order
            to prevent timeouts, you must set this to ``False``. If this is
            set to ``False``\, then this function will always return ``None``.
        roles: List[:class:`abc.Snowflake`]
            A list of :class:`abc.Snowflake` that represent roles to include in the pruning process. If a member
            has a role that is not specified, they'll be excluded.

        Raises
        ------
        Forbidden
            You do not have permissions to prune members.
        HTTPException
            An error occurred while pruning members.
        InvalidArgument
            An integer was not passed for ``days``.

        Returns
        -------
        Optional[:class:`int`]
            The number of members pruned. If ``compute_prune_count`` is ``False``
            then this returns ``None``.
        """
        ...
    
    async def templates(self) -> List[Template]:
        """|coro|

        Gets the list of templates from this guild.

        Requires :attr:`~.Permissions.manage_guild` permissions.

        .. versionadded:: 1.7

        Raises
        ------
        Forbidden
            You don't have permissions to get the templates.

        Returns
        -------
        List[:class:`Template`]
            The templates for this guild.
        """
        ...
    
    async def webhooks(self) -> List[Webhook]:
        """|coro|

        Gets the list of webhooks from this guild.

        Requires :attr:`~.Permissions.manage_webhooks` permissions.

        Raises
        ------
        Forbidden
            You don't have permissions to get the webhooks.

        Returns
        -------
        List[:class:`Webhook`]
            The webhooks for this guild.
        """
        ...
    
    async def estimate_pruned_members(self, *, days: int, roles: List[Snowflake] = ...) -> Optional[int]:
        """|coro|

        Similar to :meth:`prune_members` except instead of actually
        pruning members, it returns how many members it would prune
        from the guild had it been called.

        Parameters
        ----------
        days: :class:`int`
            The number of days before counting as inactive.
        roles: List[:class:`abc.Snowflake`]
            A list of :class:`abc.Snowflake` that represent roles to include in the estimate. If a member
            has a role that is not specified, they'll be excluded.

            .. versionadded:: 1.7

        Raises
        ------
        Forbidden
            You do not have permissions to prune members.
        HTTPException
            An error occurred while fetching the prune members estimate.
        InvalidArgument
            An integer was not passed for ``days``.

        Returns
        -------
        :class:`int`
            The number of members estimated to be pruned.
        """
        ...
    
    async def invites(self) -> List[Invite]:
        """|coro|

        Returns a list of all active instant invites from the guild.

        You must have the :attr:`~Permissions.manage_guild` permission to get
        this information.

        Raises
        ------
        Forbidden
            You do not have proper permissions to get the information.
        HTTPException
            An error occurred while fetching the information.

        Returns
        -------
        List[:class:`Invite`]
            The list of invites that are currently active.


        .. note::

            This method does not include the Guild's vanity URL.
            To get the vanity URL :class:`Invite`, refer to :meth:`Guild.vanity_invite`.
        """
        ...
    
    async def create_template(self, *, name: str, description: str = ...) -> Template:
        """|coro|

        Creates a template for the guild.

        You must have the :attr:`~Permissions.manage_guild` permission to
        do this.

        .. versionadded:: 1.7

        Parameters
        ----------
        name: :class:`str`
            The name of the template.
        description: :class:`str`
            The description of the template.
        """
        ...
    
    async def create_integration(self, *, type: IntegrationType, id: int) -> None:
        """|coro|

        Attaches an integration to the guild.

        You must have the :attr:`~Permissions.manage_guild` permission to
        do this.

        .. versionadded:: 1.4

        Parameters
        ----------
        type: :class:`str`
            The integration type (e.g. Twitch).
        id: :class:`int`
            The integration ID.

        Raises
        ------
        Forbidden
            You do not have permission to create the integration.
        HTTPException
            The account could not be found.
        """
        ...
    
    async def integrations(self) -> List[Integration]:
        """|coro|

        Returns a list of all integrations attached to the guild.

        You must have the :attr:`~Permissions.manage_guild` permission to
        do this.

        .. versionadded:: 1.4

        Raises
        ------
        Forbidden
            You do not have permission to create the integration.
        HTTPException
            Fetching the integrations failed.

        Returns
        -------
        List[:class:`Integration`]
            The list of integrations that are attached to the guild.
        """
        ...
    
    async def fetch_stickers(self) -> List[GuildSticker]:
        r"""|coro|

        Retrieves a list of all :class:`Sticker`\s for the guild.

        .. versionadded:: 2.0

        .. note::

            This method is an API call. For general usage, consider :attr:`stickers` instead.

        Raises
        ------
        HTTPException
            An error occurred fetching the stickers.

        Returns
        -------
        List[:class:`GuildSticker`]
            The retrieved stickers.
        """
        ...
    
    async def fetch_sticker(self, sticker_id: int, /) -> GuildSticker:
        """|coro|

        Retrieves a custom :class:`Sticker` from the guild.

        .. versionadded:: 2.0

        .. note::

            This method is an API call.
            For general usage, consider iterating over :attr:`stickers` instead.

        Parameters
        ----------
        sticker_id: :class:`int`
            The sticker's ID.

        Raises
        ------
        NotFound
            The sticker requested could not be found.
        HTTPException
            An error occurred fetching the sticker.

        Returns
        -------
        :class:`GuildSticker`
            The retrieved sticker.
        """
        ...
    
    async def create_sticker(self, *, name: str, description: Optional[str] = ..., emoji: str, file: File, reason: Optional[str] = ...) -> GuildSticker:
        """|coro|

        Creates a :class:`Sticker` for the guild.

        You must have :attr:`~Permissions.manage_emojis_and_stickers` permission to
        do this.

        .. versionadded:: 2.0

        Parameters
        ----------
        name: :class:`str`
            The sticker name. Must be at least 2 characters.
        description: Optional[:class:`str`]
            The sticker's description. Can be ``None``.
        emoji: :class:`str`
            The name of a unicode emoji that represents the sticker's expression.
        file: :class:`File`
            The file of the sticker to upload.
        reason: :class:`str`
            The reason for creating this sticker. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You are not allowed to create stickers.
        HTTPException
            An error occurred creating a sticker.

        Returns
        -------
        :class:`GuildSticker`
            The created sticker.
        """
        ...
    
    async def delete_sticker(self, sticker: Snowflake, *, reason: Optional[str] = ...) -> None:
        """|coro|

        Deletes the custom :class:`Sticker` from the guild.

        You must have :attr:`~Permissions.manage_emojis_and_stickers` permission to
        do this.

        .. versionadded:: 2.0

        Parameters
        ----------
        sticker: :class:`abc.Snowflake`
            The sticker you are deleting.
        reason: Optional[:class:`str`]
            The reason for deleting this sticker. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You are not allowed to delete stickers.
        HTTPException
            An error occurred deleting the sticker.
        """
        ...
    
    async def fetch_emojis(self) -> List[Emoji]:
        r"""|coro|

        Retrieves all custom :class:`Emoji`\s from the guild.

        .. note::

            This method is an API call. For general usage, consider :attr:`emojis` instead.

        Raises
        ------
        HTTPException
            An error occurred fetching the emojis.

        Returns
        -------
        List[:class:`Emoji`]
            The retrieved emojis.
        """
        ...
    
    async def fetch_emoji(self, emoji_id: int, /) -> Emoji:
        """|coro|

        Retrieves a custom :class:`Emoji` from the guild.

        .. note::

            This method is an API call.
            For general usage, consider iterating over :attr:`emojis` instead.

        Parameters
        ----------
        emoji_id: :class:`int`
            The emoji's ID.

        Raises
        ------
        NotFound
            The emoji requested could not be found.
        HTTPException
            An error occurred fetching the emoji.

        Returns
        -------
        :class:`Emoji`
            The retrieved emoji.
        """
        ...
    
    async def create_custom_emoji(self, *, name: str, image: Union[bytes, Asset, Attachment, File], roles: List[Role] = ..., reason: Optional[str] = ...) -> Emoji:
        r"""|coro|

        Creates a custom :class:`Emoji` for the guild.

        There is currently a limit of 50 static and animated emojis respectively per guild,
        unless the guild has the ``MORE_EMOJI`` feature which extends the limit to 200.

        You must have the :attr:`~Permissions.manage_emojis` permission to
        do this.

        .. versionchanged:: 2.1
            The ``image`` parameter now accepts :class:`File`, :class:`Attachment`, and :class:`Asset`.

        Parameters
        ----------
        name: :class:`str`
            The emoji name. Must be at least 2 characters.
        image: Union[:class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]
            The :term:`py:bytes-like object`, :class:`File`, :class:`Attachment`, or :class:`Asset`
            representing the image data to use. Only JPG, PNG and GIF images are supported.
        roles: List[:class:`Role`]
            A :class:`list` of :class:`Role`\s that can use this emoji. Leave empty to make it available to everyone.
        reason: Optional[:class:`str`]
            The reason for creating this emoji. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You are not allowed to create emojis.
        HTTPException
            An error occurred creating an emoji.

        Returns
        -------
        :class:`Emoji`
            The created emoji.
        """
        ...
    
    async def delete_emoji(self, emoji: Snowflake, *, reason: Optional[str] = ...) -> None:
        """|coro|

        Deletes the custom :class:`Emoji` from the guild.

        You must have :attr:`~Permissions.manage_emojis` permission to
        do this.

        Parameters
        ----------
        emoji: :class:`abc.Snowflake`
            The emoji you are deleting.
        reason: Optional[:class:`str`]
            The reason for deleting this emoji. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You are not allowed to delete emojis.
        HTTPException
            An error occurred deleting the emoji.
        """
        ...
    
    async def fetch_roles(self, *, cache: bool = ...) -> List[Role]:
        """|coro|

        Retrieves all :class:`Role` that the guild has.

        .. note::

            This method is an API call. For general usage, consider :attr:`roles` instead.

        Parameters
        ----------
        cache: bool
            Whether or not to also update this guilds
            role cache. Defaults to ``False``.

        Raises
        ------
        HTTPException
            Retrieving the roles failed.

        Returns
        -------
        List[:class:`Role`]
            All roles in the guild.
        """
        ...
    
    @overload
    async def create_role(self, *, reason: Optional[str] = ..., name: str = ..., permissions: Permissions = ..., colour: Union[Colour, int] = ..., hoist: bool = ..., mentionable: bool = ..., icon: Optional[Union[str, bytes, Asset, Attachment, File]] = ...) -> Role:
        ...
    
    @overload
    async def create_role(self, *, reason: Optional[str] = ..., name: str = ..., permissions: Permissions = ..., color: Union[Colour, int] = ..., hoist: bool = ..., mentionable: bool = ..., icon: Optional[Union[str, bytes, Asset, Attachment, File]] = ...) -> Role:
        ...
    
    async def create_role(self, *, name: str = ..., permissions: Permissions = ..., color: Union[Colour, int] = ..., colour: Union[Colour, int] = ..., hoist: bool = ..., mentionable: bool = ..., icon: Optional[Union[str, bytes, Asset, Attachment, File]] = ..., reason: Optional[str] = ...) -> Role:
        """|coro|

        Creates a :class:`Role` for the guild.

        All fields are optional.

        You must have the :attr:`~Permissions.manage_roles` permission to
        do this.

        .. versionchanged:: 1.6
            Can now pass ``int`` to ``colour`` keyword-only parameter.

        .. versionchanged:: 2.1
            The ``icon`` parameter now accepts :class:`File`, :class:`Attachment`, and :class:`Asset`.

        Parameters
        ----------
        name: :class:`str`
            The role name. Defaults to 'new role'.
        permissions: :class:`Permissions`
            The permissions to have. Defaults to no permissions.
        colour: Union[:class:`Colour`, :class:`int`]
            The colour for the role. Defaults to :meth:`Colour.default`.
            This is aliased to ``color`` as well.
        hoist: :class:`bool`
            Indicates if the role should be shown separately in the member list.
            Defaults to ``False``.
        mentionable: :class:`bool`
            Indicates if the role should be mentionable by others.
            Defaults to ``False``.
        icon: Optional[Union[:class:`str`, :class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]]
            The icon of the role. Supports unicode emojis and images
        reason: Optional[:class:`str`]
            The reason for creating this role. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have permissions to create the role.
        HTTPException
            Creating the role failed.
        InvalidArgument
            An invalid keyword argument was given.

        Returns
        -------
        :class:`Role`
            The newly created role.
        """
        ...
    
    async def edit_role_positions(self, positions: Dict[Snowflake, int], *, reason: Optional[str] = ...) -> List[Role]:
        """|coro|

        Bulk edits a list of :class:`Role` in the guild.

        You must have the :attr:`~Permissions.manage_roles` permission to
        do this.

        .. versionadded:: 1.4

        Example:

        .. code-block:: python3

            positions = {
                bots_role: 1, # penultimate role
                tester_role: 2,
                admin_role: 6
            }

            await guild.edit_role_positions(positions=positions)

        Parameters
        ----------
        positions
            A :class:`dict` of :class:`Role` to :class:`int` to change the positions
            of each given role.
        reason: Optional[:class:`str`]
            The reason for editing the role positions. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have permissions to move the roles.
        HTTPException
            Moving the roles failed.
        InvalidArgument
            An invalid keyword argument was given.

        Returns
        -------
        List[:class:`Role`]
            A list of all the roles in the guild.
        """
        ...
    
    async def kick(self, user: Snowflake, *, reason: Optional[str] = ...) -> None:
        """|coro|

        Kicks a user from the guild.

        The user must meet the :class:`abc.Snowflake` abc.

        You must have the :attr:`~Permissions.kick_members` permission to
        do this.

        Parameters
        ----------
        user: :class:`abc.Snowflake`
            The user to kick from their guild.
        reason: Optional[:class:`str`]
            The reason the user got kicked.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to kick.
        HTTPException
            Kicking failed.
        """
        ...
    
    async def ban(self, user: Snowflake, *, reason: Optional[str] = ..., delete_message_seconds: Optional[int] = ..., delete_message_days: Optional[Literal[0, 1, 2, 3, 4, 5, 6, 7]] = ...) -> None:
        """|coro|

        Bans a user from the guild.

        The user must meet the :class:`abc.Snowflake` abc.

        You must have the :attr:`~Permissions.ban_members` permission to
        do this.

        For backwards compatibility reasons, by default one day worth of messages will be deleted.

        .. warning::
            delete_message_days is deprecated and will be removed in a future version.
            Use delete_message_seconds instead.

        Parameters
        ----------
        user: :class:`abc.Snowflake`
            The user to ban from their guild.
        delete_message_seconds: Optional[:class:`int`]
            The number of seconds worth of messages to delete from the user
            in the guild. The minimum is 0 and the maximum is 604800 (7 days).

            .. versionadded:: 2.3
        delete_message_days: Optional[:class:`int`]
            The number of days worth of messages to delete from the user
            in the guild. The minimum is 0 and the maximum is 7.

            .. deprecated:: 2.3
        reason: Optional[:class:`str`]
            The reason the user got banned.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to ban.
        HTTPException
            Banning failed.
        """
        ...
    
    async def unban(self, user: Snowflake, *, reason: Optional[str] = ...) -> None:
        """|coro|

        Unbans a user from the guild.

        The user must meet the :class:`abc.Snowflake` abc.

        You must have the :attr:`~Permissions.ban_members` permission to
        do this.

        Parameters
        ----------
        user: :class:`abc.Snowflake`
            The user to unban.
        reason: Optional[:class:`str`]
            The reason for doing this action. Shows up on the audit log.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to unban.
        HTTPException
            Unbanning failed.
        """
        ...
    
    async def vanity_invite(self) -> Optional[Invite]:
        """|coro|

        Returns the guild's special vanity invite.

        The guild must have ``VANITY_URL`` in :attr:`~Guild.features`.

        You must have the :attr:`~Permissions.manage_guild` permission to use
        this as well.

        Raises
        ------
        Forbidden
            You do not have the proper permissions to get this.
        HTTPException
            Retrieving the vanity invite failed.

        Returns
        -------
        Optional[:class:`Invite`]
            The special vanity invite. If ``None`` then the guild does not
            have a vanity invite set.
        """
        ...
    
    def audit_logs(self, *, limit: Optional[int] = ..., before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ..., oldest_first: Optional[bool] = ..., user: Optional[Snowflake] = ..., action: Optional[AuditLogAction] = ...) -> AuditLogIterator:
        """Returns an :class:`AsyncIterator` that enables receiving the guild's audit logs.

        You must have the :attr:`~Permissions.view_audit_log` permission to use this.

        Examples
        --------

        Getting the first 100 entries: ::

            async for entry in guild.audit_logs(limit=100):
                print(f'{entry.user} did {entry.action} to {entry.target}')

        Getting entries for a specific action: ::

            async for entry in guild.audit_logs(action=nextcord.AuditLogAction.ban):
                print(f'{entry.user} banned {entry.target}')

        Getting entries made by a specific user: ::

            entries = await guild.audit_logs(limit=None, user=guild.me).flatten()
            await channel.send(f'I made {len(entries)} moderation actions.')

        Parameters
        ----------
        limit: Optional[:class:`int`]
            The number of entries to retrieve. If ``None`` retrieve all entries.
        before: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
            Retrieve entries before this date or entry.
            If a datetime is provided, it is recommended to use a UTC aware datetime.
            If the datetime is naive, it is assumed to be local time.
        after: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
            Retrieve entries after this date or entry.
            If a datetime is provided, it is recommended to use a UTC aware datetime.
            If the datetime is naive, it is assumed to be local time.
        oldest_first: Optional[:class:`bool`]
            If set to ``True``, return entries in oldest->newest order. Defaults to ``True`` if
            ``after`` is specified, otherwise ``False``.
        user: Optional[:class:`abc.Snowflake`]
            The moderator to filter entries from.
        action: Optional[:class:`AuditLogAction`]
            The action to filter with.

        Raises
        ------
        Forbidden
            You are not allowed to fetch audit logs
        HTTPException
            An error occurred while fetching the audit logs.

        Yields
        ------
        :class:`AuditLogEntry`
            The audit log entry.
        """
        ...
    
    async def widget(self) -> Widget:
        """|coro|

        Returns the widget of the guild.

        .. note::

            The guild must have the widget enabled to get this information.

        Raises
        ------
        Forbidden
            The widget for this guild is disabled.
        HTTPException
            Retrieving the widget failed.

        Returns
        -------
        :class:`Widget`
            The guild's widget.
        """
        ...
    
    async def edit_widget(self, *, enabled: bool = ..., channel: Optional[Snowflake] = ...) -> None:
        """|coro|

        Edits the widget of the guild.

        You must have the :attr:`~Permissions.manage_guild` permission to
        use this

        .. versionadded:: 2.0

        Parameters
        ----------
        enabled: :class:`bool`
            Whether to enable the widget for the guild.
        channel: Optional[:class:`~nextcord.abc.Snowflake`]
            The new widget channel. ``None`` removes the widget channel.

        Raises
        ------
        Forbidden
            You do not have permission to edit the widget.
        HTTPException
            Editing the widget failed.
        """
        ...
    
    async def chunk(self, *, cache: bool = ...) -> Optional[List[Member]]:
        """|coro|

        Requests all members that belong to this guild. In order to use this,
        :meth:`Intents.members` must be enabled.

        This is a websocket operation and can be slow.

        .. versionadded:: 1.5

        Parameters
        ----------
        cache: :class:`bool`
            Whether to cache the members as well.

        Raises
        ------
        ClientException
            The members intent is not enabled.

        Returns
        -------
        Optional[List[:class:`Member`]]
             Returns a list of all the members in the guild.
        """
        ...
    
    async def query_members(self, query: Optional[str] = ..., *, limit: int = ..., user_ids: Optional[List[int]] = ..., presences: bool = ..., cache: bool = ...) -> List[Member]:
        """|coro|

        Request members that belong to this guild whose username starts with
        the query given.

        This is a websocket operation and can be slow.

        .. versionadded:: 1.3

        Parameters
        ----------
        query: Optional[:class:`str`]
            The string that the username's start with.
        limit: :class:`int`
            The maximum number of members to send back. This must be
            a number between 5 and 100.
        presences: :class:`bool`
            Whether to request for presences to be provided. This defaults
            to ``False``.

            .. versionadded:: 1.6

        cache: :class:`bool`
            Whether to cache the members internally. This makes operations
            such as :meth:`get_member` work for those that matched.
        user_ids: Optional[List[:class:`int`]]
            List of user IDs to search for. If the user ID is not in the guild then it won't be returned.

            .. versionadded:: 1.4


        Raises
        ------
        asyncio.TimeoutError
            The query timed out waiting for the members.
        ValueError
            Invalid parameters were passed to the function
        ClientException
            The presences intent is not enabled.

        Returns
        -------
        List[:class:`Member`]
            The list of members that have matched the query.
        """
        ...
    
    async def change_voice_state(self, *, channel: Optional[VocalGuildChannel], self_mute: bool = ..., self_deaf: bool = ...) -> None:
        """|coro|

        Changes client's voice state in the guild.

        .. versionadded:: 1.4

        Parameters
        ----------
        channel: Optional[:class:`VoiceChannel`]
            Channel the client wants to join. Use ``None`` to disconnect.
        self_mute: :class:`bool`
            Indicates if the client should be self-muted.
        self_deaf: :class:`bool`
            Indicates if the client should be self-deafened.
        """
        ...
    
    def fetch_scheduled_events(self, *, with_users: bool = ...) -> ScheduledEventIterator:
        """Retrieves an :class:`.AsyncIterator` that enables receiving scheduled
        events on this guild

        .. note::

            This method is an API call. For general usage, consider
            :attr:`scheduled_events` instead.

        .. versionadded:: 2.0

        Parameters
        ----------
        with_users: Optional[:class:`bool`]
            If the event should be received with :attr:`ScheduledEvent.users`
            This defaults to ``False`` - the events' :attr:`~ScheduledEvent.users`
            will be empty.

        Raises
        ------
        HTTPException
            Getting the events failed.

        Yields
        ------
        :class:`.ScheduledEvent`
            The event with users if applicable

        Examples
        --------

        Usage ::

            async for event in guild.fetch_scheduled_events():
                print(event.name)

        Flattening into a list ::

            events = await guild.fetch_scheduled_events().flatten()
            # events is now a list of ScheduledEvent...
        """
        ...
    
    def get_scheduled_event(self, event_id: int) -> Optional[ScheduledEvent]:
        """Get a scheduled event from cache by id.

        .. note::

            This may not return the updated users, use
            :meth:`~Guild.fetch_scheduled_event` if that is desired.

        Parameters
        ----------
        event_id : int
            The scheduled event id to fetch.

        Returns
        -------
        Optional[ScheduledEvent]
            The event object, if found.
        """
        ...
    
    async def fetch_scheduled_event(self, event_id: int, *, with_users: bool = ...) -> ScheduledEvent:
        """|coro|

        Fetch a scheduled event object.

        .. note::

            This is an api call, if updated users is not needed,
            consisder :meth:`~Guild.get_scheduled_event`

        Parameters
        ----------
        event_id: :class:`int`
            The event id to fetch
        with_users: :class:`bool`
            If the users should be received and cached too, by default False

        Returns
        -------
        :class:`ScheduledEvent`
            The received event object
        """
        ...
    
    async def create_scheduled_event(self, *, name: str, entity_type: ScheduledEventEntityType, start_time: datetime.datetime, channel: abc.GuildChannel = ..., metadata: EntityMetadata = ..., privacy_level: ScheduledEventPrivacyLevel = ..., end_time: datetime.datetime = ..., description: str = ..., image: Optional[Union[bytes, Asset, Attachment, File]] = ..., reason: Optional[str] = ...) -> ScheduledEvent:
        """|coro|

        Create a new scheduled event object.

        .. versionchanged:: 2.1
            The ``image`` parameter now accepts :class:`File`, :class:`Attachment`, and :class:`Asset`.

        Parameters
        ----------
        channel: :class:`abc.GuildChannel`
            The channel the event will happen in, if any
        metadata: :class:`EntityMetadata`
            The metadata for the event
        name: :class:`str`
            The name of the event
        privacy_level: :class:`ScheduledEventPrivacyLevel`
            The privacy level for the event
        start_time: :class:`py:datetime.datetime`
            The scheduled start time
        end_time: :class:`py:datetime.datetime`
            The scheduled end time
        description: :class:`str`
            The description for the event
        entity_type: :class:`ScheduledEventEntityType`
            The type of event
        image: Optional[Union[:class:`bytes`, :class:`Asset`, :class:`Attachment`, :class:`File`]]
            A :term:`py:bytes-like object`, :class:`File`, :class:`Attachment`, or :class:`Asset`
            representing the cover image.
        reason: Optional[:class:`str`]
            The reason for creating this scheduled event. Shows up in the audit logs.

        Returns
        -------
        :class:`ScheduledEvent`
            The created event object.
        """
        ...
    
    def get_application_commands(self, rollout: bool = ...): # -> List[BaseApplicationCommand]:
        """Gets all application commands registered for this guild.

        Parameters
        ----------
        rollout: :class:`bool`

        Returns
        -------

        """
        ...
    
    def add_application_command(self, app_cmd: BaseApplicationCommand, overwrite: bool = ..., use_rollout: bool = ...) -> None:
        ...
    
    async def deploy_application_commands(self, data: Optional[List[ApplicationCommandPayload]] = ..., associate_known: bool = ..., delete_unknown: bool = ..., update_known: bool = ...) -> None:
        ...
    
    async def sync_application_commands(self, data: Optional[List[ApplicationCommandPayload]] = ..., *, associate_known: bool = ..., delete_unknown: bool = ..., update_known: bool = ..., register_new: bool = ...) -> None:
        """|coro|
        Syncs the locally added application commands with this Guild.

        Parameters
        ----------
        data: Optional[List[:class:`dict`]]
            Data to use when comparing local application commands to what Discord has. Should be a list of application
            command data from Discord. If left as ``None``, it will be fetched if needed. Defaults to ``None``.
        associate_known: :class:`bool`
            If local commands that match a command already on Discord should be associated with each other.
            Defaults to ``True``.
        delete_unknown: :class:`bool`
            If commands on Discord that don't match a local command should be deleted. Defaults to ``True``.
        update_known: :class:`bool`
            If commands on Discord have a basic match with a local command, but don't fully match, should be updated.
            Defaults to ``True``.
        register_new: :class:`bool`
            If a local command that doesn't have a basic match on Discord should be added to Discord.
            Defaults to ``True``.
        """
        ...
    
    async def rollout_application_commands(self, associate_known: bool = ..., delete_unknown: bool = ..., update_known: bool = ..., register_new: bool = ...) -> None:
        """|coro|
        Rolls out application commands to the guild, associating, deleting, updating, and/or newly
        registering as needed.

        Parameters
        ----------
        associate_known: :class:`bool`
            Whether commands on Discord that match a locally added command should be associated with each other.
            Defaults to ``True``
        delete_unknown
        update_known
        register_new
        """
        ...
    
    async def delete_unknown_application_commands(self, data: Optional[List[ApplicationCommandPayload]] = ...) -> None:
        ...
    
    async def associate_application_commands(self, data: Optional[List[ApplicationCommandPayload]] = ...) -> None:
        ...
    
    async def update_application_commands(self, data: Optional[List[ApplicationCommandPayload]] = ...) -> None:
        ...
    
    async def register_new_application_commands(self, data: Optional[List[ApplicationCommandPayload]] = ...) -> None:
        ...
    
    async def register_application_commands(self, *commands: BaseApplicationCommand) -> None:
        ...
    
    async def delete_application_commands(self, *commands: BaseApplicationCommand) -> None:
        ...
    
    async def auto_moderation_rules(self) -> List[AutoModerationRule]:
        """|coro|

        Get the list of auto moderation rules from this guild.

        Requires the :attr:`~Permissions.manage_guild` permission.

        .. versionadded:: 2.1

        Raises
        ------
        Forbidden
            You do not have permission to fetch the auto moderation rules.

        Returns
        -------
        List[:class:`AutoModerationRule`]
            The auto moderation rules of this guild.
        """
        ...
    
    async def fetch_auto_moderation_rule(self, rule_id: int, /) -> AutoModerationRule:
        """|coro|

        Retrieves a :class:`AutoModerationRule` from this guild by its ID

        Requires the :attr:`~Permissions.manage_guild` permission.

        .. versionadded:: 2.1

        Parameters
        ----------
        rule_id: :class:`int`
            The ID of the auto moderation rule to fetch.

        Raises
        ------
        NotFound
            The requested rule could not be found.
        Forbidden
            You do not have permission to fetch auto moderation rules.
        HTTPException
            Fetching the rule failed.

        Returns
        -------
        :class:`AutoModerationRule`
            The found auto moderation rule.
        """
        ...
    
    async def create_auto_moderation_rule(self, *, name: str, event_type: AutoModerationEventType, trigger_type: AutoModerationTriggerType, actions: List[AutoModerationAction], trigger_metadata: Optional[AutoModerationTriggerMetadata] = ..., enabled: Optional[bool] = ..., exempt_roles: Optional[List[Snowflake]] = ..., exempt_channels: Optional[List[Snowflake]] = ..., reason: Optional[str] = ...) -> AutoModerationRule:
        """|coro|

        Create a new auto moderation rule.

        Requires the :attr:`~Permissions.manage_guild` permission.

        .. versionadded:: 2.1

        Parameters
        ----------
        name: :class:`str`
            The name to use for this rule.
        event_type: :class:`AutoModerationEventType`
            The type of event conteto listen to for this rule.
        actions: List[:class:`AutoModerationAction`]
            The actions to execute when this rule is triggered.
        trigger_type: :class:`AutoModerationTriggerType`
            The type of content that triggers this rule.
        trigger_metadata: Optinal[:class:`AutoModerationTriggerMetadata`]
            The additional data to use to determine if this rule has been triggered.
        enabled: Optional[:class:`bool`]
            If this rule should be enabled.
        exempt_roles: Optional[List[:class:`abc.Snowflake`]]
            Roles that should be exempt from this rule.
        exempt_channels: Optional[List[:class:`abc.Snowflake`]]
            Channels that should be exempt from this rule.
        reason: Optional[:class:`str`]
            The reason for creating this rule. Shows in the audit log.

        Raises
        ------
        Forbidden
            You do not have permission to create auto moderation rules.
        HTTPException
            Creating the rule failed.
        InvalidArgument
            An invalid type was passed for an argument.

        Returns
        -------
        :class:`AutoModerationRule`
            The newly created auto moderation rule.
        """
        ...
    
    def parse_mentions(self, text: str) -> List[Union[Member, User]]:
        """Parses user mentions in a string and returns a list of :class:`Member` objects.
        If the member is not in the guild, a :class:`User` object is returned for that member instead.

        .. note::

            This does not include role or channel mentions. See :meth:`~Guild.parse_role_mentions`
            for :class:`Role` objects and :meth:`~Guild.parse_channel_mentions` for
            :class:`~abc.GuildChannel` objects.

        .. note::

            Only members or users found in the cache will be returned. To get the IDs of all users
            mentioned, use :func:`~utils.parse_raw_mentions` instead.

        .. versionadded:: 2.2

        Parameters
        ----------
        text: :class:`str`
            String to parse mentions in.

        Returns
        -------
        List[Union[:class:`Member`, :class:`User`]]
            List of :class:`Member` or :class:`User` objects that were mentioned in the string.
        """
        ...
    
    def parse_role_mentions(self, text: str) -> List[Role]:
        """Parses role mentions in a string and returns a list of :class:`Role` objects.

        .. note::

            Only cached roles found in the :class:`Guild` will be returned. To get the IDs
            of all roles mentioned, use :func:`~utils.parse_raw_role_mentions` instead.

        .. versionadded:: 2.2

        Parameters
        ----------
        text: :class:`str`
            String to parse mentions in.

        Returns
        -------
        List[:class:`Role`]
            List of :class:`Role` objects that were mentioned in the string.
        """
        ...
    
    def parse_channel_mentions(self, text: str) -> List[abc.GuildChannel]:
        """Parses channel mentions in a string and returns a list of :class:`~abc.GuildChannel` objects.

        .. note::

            Only cached channels found in the :class:`Guild` will be returned. To get the IDs of all
            channels mentioned, use :func:`~utils.parse_raw_channel_mentions` instead.

        .. versionadded:: 2.2

        Parameters
        ----------
        text: :class:`str`
            String to parse mentions in.

        Returns
        -------
        List[:class:`~abc.GuildChannel`]
            List of :class:`~abc.GuildChannel` objects that were mentioned in the string.
        """
        ...
    


