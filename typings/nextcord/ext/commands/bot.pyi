"""
This type stub file was generated by pyright.
"""

import asyncio
import types
import nextcord
import aiohttp
from typing import Any, Awaitable, Callable, Dict, Iterable, List, Mapping, Optional, Sequence, TYPE_CHECKING, Type, TypeVar, Union
from . import errors
from .cog import Cog
from .context import Context
from .core import GroupMixin
from .help import HelpCommand
from nextcord.activity import BaseActivity
from nextcord.enums import Status
from nextcord.flags import MemberCacheFlags
from nextcord.mentions import AllowedMentions
from nextcord.message import Message
from nextcord.types.checks import ApplicationCheck, ApplicationHook
from ._types import Check, CoroFunc

if TYPE_CHECKING:
    ...
__all__ = ("when_mentioned", "when_mentioned_or", "Bot", "AutoShardedBot", "MissingMessageContentIntentWarning")
MISSING: Any = ...
T = TypeVar("T")
CFT = TypeVar("CFT", bound="CoroFunc")
CXT = TypeVar("CXT", bound="Context")
def when_mentioned(bot: Union[Bot, AutoShardedBot], msg: Message) -> List[str]:
    """A callable that implements a command prefix equivalent to being mentioned.

    These are meant to be passed into the :attr:`.Bot.command_prefix` attribute.
    """
    ...

def when_mentioned_or(*prefixes: str) -> Callable[[Union[Bot, AutoShardedBot], Message], List[str]]:
    """A callable that implements when mentioned or other prefixes provided.

    These are meant to be passed into the :attr:`.Bot.command_prefix` attribute.

    Example
    -------

    .. code-block:: python3

        bot = commands.Bot(command_prefix=commands.when_mentioned_or('!'))


    .. note::

        This callable returns another callable, so if this is done inside a custom
        callable, you must call the returned callable, for example:

        .. code-block:: python3

            async def get_prefix(bot, message):
                extras = await prefixes_for(message.guild) # returns a list
                return commands.when_mentioned_or(*extras)(bot, message)


    See Also
    --------
    :func:`.when_mentioned`
    """
    ...

class MissingMessageContentIntentWarning(UserWarning):
    """Warning category raised when instantiating a :class:`~nextcord.ext.commands.Bot` with a
    :attr:`~nextcord.ext.commands.Bot.command_prefix` but without the :attr:`~nextcord.Intents.message_content`
    intent enabled.

    This warning is not raised when the :attr:`~nextcord.ext.commands.Bot.command_prefix`
    is set to an empty iterable or :func:`when_mentioned <nextcord.ext.commands.when_mentioned>`.

    This warning can be silenced using :func:`warnings.simplefilter`.

    .. code-block:: python3

        import warnings
        from nextcord.ext import commands

        warnings.simplefilter("ignore", commands.MissingMessageContentIntentWarning)
    """
    ...


_NonCallablePrefix = Union[str, Sequence[str]]
class BotBase(GroupMixin):
    def __init__(self, command_prefix: Union[_NonCallablePrefix, Callable[[Union[Bot, AutoShardedBot], Message], Union[Awaitable[_NonCallablePrefix], _NonCallablePrefix],],], help_command: Optional[HelpCommand], description: Optional[str], *, owner_id: Optional[int], owner_ids: Optional[Iterable[int]], strip_after_prefix: bool, case_insensitive: bool) -> None:
        ...
    
    def dispatch(self, event_name: str, *args: Any, **kwargs: Any) -> None:
        ...
    
    @nextcord.utils.copy_doc(nextcord.Client.close)
    async def close(self) -> None:
        ...
    
    async def on_command_error(self, context: Context, exception: errors.CommandError) -> None:
        """|coro|

        The default command error handler provided by the bot.

        By default this prints to :data:`~sys.stderr` however it could be
        overridden to have a different implementation.

        This only fires if you do not specify any listeners for command error.
        """
        ...
    
    def check(self, func: T) -> T:
        r"""A decorator that adds a global check to the bot.

        A global check is similar to a :func:`.check` that is applied
        on a per command basis except it is run before any command checks
        have been verified and applies to every command the bot has.

        .. note::

            This function can either be a regular function or a coroutine.

        Similar to a command :func:`.check`\, this takes a single parameter
        of type :class:`.Context` and can only raise exceptions inherited from
        :exc:`.CommandError`.

        Example
        -------

        .. code-block:: python3

            @bot.check
            def check_commands(ctx):
                return ctx.command.qualified_name in allowed_commands

        """
        ...
    
    def add_check(self, func: Check, *, call_once: bool = ...) -> None:
        """Adds a global check to the bot.

        This is the non-decorator interface to :meth:`.check`
        and :meth:`.check_once`.

        Parameters
        ----------
        func
            The function that was used as a global check.
        call_once: :class:`bool`
            If the function should only be called once per
            :meth:`.invoke` call.
        """
        ...
    
    def remove_check(self, func: Check, *, call_once: bool = ...) -> None:
        """Removes a global check from the bot.

        This function is idempotent and will not raise an exception
        if the function is not in the global checks.

        Parameters
        ----------
        func
            The function to remove from the global checks.
        call_once: :class:`bool`
            If the function was added with ``call_once=True`` in
            the :meth:`.Bot.add_check` call or using :meth:`.check_once`.
        """
        ...
    
    def check_once(self, func: CFT) -> CFT:
        r"""A decorator that adds a "call once" global check to the bot.

        Unlike regular global checks, this one is called only once
        per :meth:`.invoke` call.

        Regular global checks are called whenever a command is called
        or :meth:`.Command.can_run` is called. This type of check
        bypasses that and ensures that it's called only once, even inside
        the default help command.

        .. note::

            When using this function the :class:`.Context` sent to a group subcommand
            may only parse the parent command and not the subcommands due to it
            being invoked once per :meth:`.Bot.invoke` call.

        .. note::

            This function can either be a regular function or a coroutine.

        Similar to a command :func:`.check`\, this takes a single parameter
        of type :class:`.Context` and can only raise exceptions inherited from
        :exc:`.CommandError`.

        Example
        -------

        .. code-block:: python3

            @bot.check_once
            def whitelist(ctx):
                return ctx.message.author.id in my_whitelist

        """
        ...
    
    async def can_run(self, ctx: Context, *, call_once: bool = ...) -> bool:
        ...
    
    async def is_owner(self, user: nextcord.User) -> bool:
        """|coro|
        Checks if a :class:`~nextcord.User` or :class:`~nextcord.Member` is the owner of
        this bot.

        If an :attr:`owner_id` is not set, it is fetched automatically
        through the use of :meth:`~.Bot.application_info`.

        .. versionchanged:: 1.3
            The function also checks if the application is team-owned if
            :attr:`owner_ids` is not set.

        Parameters
        ----------
        user: :class:`.abc.User`
            The user to check for.

        Returns
        -------
        :class:`bool`
            Whether the user is the owner.
        """
        ...
    
    def before_invoke(self, coro: CFT) -> CFT:
        """A decorator that registers a coroutine as a pre-invoke hook.

        A pre-invoke hook is called directly before the command is
        called. This makes it a useful function to set up database
        connections or any type of set up required.

        This pre-invoke hook takes a sole parameter, a :class:`.Context`.

        .. note::

            The :meth:`~.Bot.before_invoke` and :meth:`~.Bot.after_invoke` hooks are
            only called if all checks and argument parsing procedures pass
            without error. If any check or argument parsing procedures fail
            then the hooks are not called.

        Parameters
        ----------
        coro: :ref:`coroutine <coroutine>`
            The coroutine to register as the pre-invoke hook.

        Raises
        ------
        TypeError
            The coroutine passed is not actually a coroutine.
        """
        ...
    
    def after_invoke(self, coro: CFT) -> CFT:
        r"""A decorator that registers a coroutine as a post-invoke hook.

        A post-invoke hook is called directly after the command is
        called. This makes it a useful function to clean-up database
        connections or any type of clean up required.

        This post-invoke hook takes a sole parameter, a :class:`.Context`.

        .. note::

            Similar to :meth:`~.Bot.before_invoke`\, this is not called unless
            checks and argument parsing procedures succeed. This hook is,
            however, **always** called regardless of the internal command
            callback raising an error (i.e. :exc:`.CommandInvokeError`\).
            This makes it ideal for clean-up scenarios.

        Parameters
        ----------
        coro: :ref:`coroutine <coroutine>`
            The coroutine to register as the post-invoke hook.

        Raises
        ------
        TypeError
            The coroutine passed is not actually a coroutine.
        """
        ...
    
    def add_listener(self, func: CoroFunc, name: str = ...) -> None:
        """The non decorator alternative to :meth:`.listen`.

        Parameters
        ----------
        func: :ref:`coroutine <coroutine>`
            The function to call.
        name: :class:`str`
            The name of the event to listen for. Defaults to ``func.__name__``.

        Example
        -------

        .. code-block:: python3

            async def on_ready(): pass
            async def my_message(message): pass

            bot.add_listener(on_ready)
            bot.add_listener(my_message, 'on_message')

        """
        ...
    
    def remove_listener(self, func: CoroFunc, name: str = ...) -> None:
        """Removes a listener from the pool of listeners.

        Parameters
        ----------
        func
            The function that was used as a listener to remove.
        name: :class:`str`
            The name of the event we want to remove. Defaults to
            ``func.__name__``.
        """
        ...
    
    def listen(self, name: str = ...) -> Callable[[CFT], CFT]:
        """A decorator that registers another function as an external
        event listener. Basically this allows you to listen to multiple
        events from different places e.g. such as :func:`.on_ready`

        The functions being listened to must be a :ref:`coroutine <coroutine>`.

        Example
        -------

        .. code-block:: python3

            @bot.listen()
            async def on_message(message):
                print('one')

            # in some other file...

            @bot.listen('on_message')
            async def my_message(message):
                print('two')

        Would print one and two in an unspecified order.

        Raises
        ------
        TypeError
            The function being listened to is not a coroutine.
        """
        ...
    
    def add_cog(self, cog: Cog, *, override: bool = ...) -> None:
        """Adds a "cog" to the bot.

        A cog is a class that has its own event listeners and commands.

        .. versionchanged:: 2.0

            :exc:`.ClientException` is raised when a cog with the same name
            is already loaded.

        Parameters
        ----------
        cog: :class:`.Cog`
            The cog to register to the bot.
        override: :class:`bool`
            If a previously loaded cog with the same name should be ejected
            instead of raising an error.

            .. versionadded:: 2.0

        Raises
        ------
        TypeError
            The cog does not inherit from :class:`.Cog`.
        CommandError
            An error happened during loading.
        .ClientException
            A cog with the same name is already loaded.
        """
        ...
    
    def get_cog(self, name: str) -> Optional[Cog]:
        """Gets the cog instance requested.

        If the cog is not found, ``None`` is returned instead.

        Parameters
        ----------
        name: :class:`str`
            The name of the cog you are requesting.
            This is equivalent to the name passed via keyword
            argument in class creation or the class name if unspecified.

        Returns
        -------
        Optional[:class:`Cog`]
            The cog that was requested. If not found, returns ``None``.
        """
        ...
    
    def remove_cog(self, name: str) -> Optional[Cog]:
        """Removes a cog from the bot and returns it.

        All registered commands and event listeners that the
        cog has registered will be removed as well.

        If no cog is found then this method has no effect.

        Parameters
        ----------
        name: :class:`str`
            The name of the cog to remove.

        Returns
        -------
        Optional[:class:`.Cog`]
             The cog that was removed. ``None`` if not found.
        """
        ...
    
    @property
    def cogs(self) -> Mapping[str, Cog]:
        """Mapping[:class:`str`, :class:`Cog`]: A read-only mapping of cog name to cog."""
        ...
    
    def load_extension(self, name: str, *, package: Optional[str] = ..., extras: Optional[Dict[str, Any]] = ...) -> None:
        """Loads an extension.

        An extension is a python module that contains commands, cogs, or
        listeners.

        An extension must have a global function, ``setup`` defined as
        the entry point on what to do when the extension is loaded. This entry
        point must have a single argument, the ``bot``.

        Parameters
        ----------
        name: :class:`str`
            The extension name to load. It must be dot separated like
            regular Python imports if accessing a sub-module. e.g.
            ``foo.test`` if you want to import ``foo/test.py``.
        package: Optional[:class:`str`]
            The package name to resolve relative imports with.
            This is required when loading an extension using a relative path, e.g ``.foo.test``.
            Defaults to ``None``.

            .. versionadded:: 1.7
        extras: Optional[:class:`dict`]
            A mapping of kwargs to values to be passed to your
            cog's ``__init__`` method as keyword arguments.

            Usage ::

                # main.py
                bot.load_extension("cogs.me_cog", extras={"keyword_arg": True})

                # cogs/me_cog.py
                class MeCog(commands.Cog):
                    def __init__(self, bot, keyword_arg):
                        self.bot = bot
                        self.keyword_arg = keyword_arg

                def setup(bot, **kwargs):
                    bot.add_cog(MeCog(bot, **kwargs))

                # Alternately
                def setup(bot, keyword_arg):
                    bot.add_cog(MeCog(bot, keyword_arg))

            .. versionadded:: 2.0.0

        Raises
        ------
        ExtensionNotFound
            The extension could not be imported.
            This is also raised if the name of the extension could not
            be resolved using the provided ``package`` parameter.
        ExtensionAlreadyLoaded
            The extension is already loaded.
        NoEntryPointError
            The extension does not have a setup function.
        ExtensionFailed
            The extension or its setup function had an execution error.
        InvalidSetupArguments
            ``load_extension`` was given ``extras`` but the ``setup``
            function did not take any additional arguments.
        """
        ...
    
    def unload_extension(self, name: str, *, package: Optional[str] = ...) -> None:
        """Unloads an extension.

        When the extension is unloaded, all commands, listeners, and cogs are
        removed from the bot and the module is un-imported.

        The extension can provide an optional global function, ``teardown``,
        to do miscellaneous clean-up if necessary. This function takes a single
        parameter, the ``bot``, similar to ``setup`` from
        :meth:`~.Bot.load_extension`.

        Parameters
        ----------
        name: :class:`str`
            The extension name to unload. It must be dot separated like
            regular Python imports if accessing a sub-module. e.g.
            ``foo.test`` if you want to import ``foo/test.py``.
        package: Optional[:class:`str`]
            The package name to resolve relative imports with.
            This is required when unloading an extension using a relative path, e.g ``.foo.test``.
            Defaults to ``None``.

            .. versionadded:: 1.7

        Raises
        ------
        ExtensionNotFound
            The name of the extension could not
            be resolved using the provided ``package`` parameter.
        ExtensionNotLoaded
            The extension was not loaded.
        """
        ...
    
    def reload_extension(self, name: str, *, package: Optional[str] = ...) -> None:
        """Atomically reloads an extension.

        This replaces the extension with the same extension, only refreshed. This is
        equivalent to a :meth:`unload_extension` followed by a :meth:`load_extension`
        except done in an atomic way. That is, if an operation fails mid-reload then
        the bot will roll-back to the prior working state.

        Parameters
        ----------
        name: :class:`str`
            The extension name to reload. It must be dot separated like
            regular Python imports if accessing a sub-module. e.g.
            ``foo.test`` if you want to import ``foo/test.py``.
        package: Optional[:class:`str`]
            The package name to resolve relative imports with.
            This is required when reloading an extension using a relative path, e.g ``.foo.test``.
            Defaults to ``None``.

            .. versionadded:: 1.7

        Raises
        ------
        ExtensionNotLoaded
            The extension was not loaded.
        ExtensionNotFound
            The extension could not be imported.
            This is also raised if the name of the extension could not
            be resolved using the provided ``package`` parameter.
        NoEntryPointError
            The extension does not have a setup function.
        ExtensionFailed
            The extension setup function had an execution error.
        """
        ...
    
    def load_extensions(self, names: List[str], *, package: Optional[str] = ..., packages: Optional[List[str]] = ..., extras: Optional[List[Dict[str, Any]]] = ..., stop_at_error: bool = ...) -> List[str]:
        """Loads all extensions provided in a list.

        .. note::

            By default, any exceptions found while loading will not be raised but will be printed to console (standard error/:data:`~sys.stderr`).

        .. versionadded:: 2.1

        Parameters
        ----------
        names: List[:class:`str`]
            The names of all of the extensions to load.
        package: Optional[:class:`str`]
            The package name to resolve relative imports with.
            This is required when loading an extension using a relative path, e.g ``.foo.test``.
            Defaults to ``None``.
        packages: Optional[List[:class:`str`]]
            A list of package names to resolve relative imports with.
            This is required when loading an extension using a relative path, e.g ``.foo.test``.
            Defaults to ``None``.

            Usage::

                # main.py
                bot.load_extensions(
                    [
                        ".my_cog",
                        ".my_cog_two",
                    ],
                    packages=[
                        "cogs.coolcog",
                        "cogs.coolcogtwo",
                    ],
                )

                # cogs/coolcog/my_cog.py
                class MyCog(commands.Cog):
                    def __init__(self, bot):
                        self.bot = bot

                    # ...

                def setup(bot):
                    bot.add_cog(MyCog(bot))

                # cogs/coolcogtwo/my_cog_two.py
                class MyCogTwo(commands.Cog):
                    def __init__(self, bot):
                        self.bot = bot

                    # ...

                def setup(bot):
                    bot.add_cog(MyCogTwo(bot))

        extras: Optional[List[Dict[:class:`str`, Any]]]
            A list of extra arguments to pass to the extension's setup function.

            Usage::

                # main.py
                bot.load_extensions(
                    [
                        ".my_cog",
                        ".my_cog_two",
                    ],
                    package="cogs",
                    extras=[{"my_attribute": 11}, {"my_other_attribute": 12}],
                )

                # cogs/my_cog.py
                class MyCog(commands.Cog):
                    def __init__(self, bot, my_attribute):
                        self.bot = bot
                        self.my_attribute = my_attribute

                    # ...

                def setup(bot, **kwargs):
                    bot.add_cog(MyCog(bot, **kwargs))

                # cogs/my_cog_two.py
                class MyCogTwo(commands.Cog):
                    def __init__(self, bot, my_other_attribute):
                        self.bot = bot
                        self.my_other_attribute = my_other_attribute

                    # ...

                def setup(bot, my_other_attribute):
                    bot.add_cog(MyCogTwo(bot, my_other_attribute))

        stop_at_error: :class:`bool`
            Whether or not an exception should be raised if we encounter one. Set to ``False`` by
            default.

        Returns
        -------
        List[:class:`str`]
            A list that contains the names of all of the extensions
            that loaded successfully.

        Raises
        ------
        ValueError
            The length of ``packages`` or the length of ``extras` is not equal to the length of ``names``.
        InvalidArgument
            You passed in both ``package`` and ``packages``.
        ExtensionNotFound
            An extension could not be imported.
        ExtensionAlreadyLoaded
            An extension is already loaded.
        NoEntryPointError
            An extension does not have a setup function.
        ExtensionFailed
            An extension or its setup function had an execution error.
        """
        ...
    
    def load_extensions_from_module(self, source_module: str, *, ignore: Optional[List[str]] = ..., stop_at_error: bool = ...) -> List[str]:
        """Loads all extensions found in a module.

        Once an extension found in a module has been loaded and did not throw
        any exceptions, it will be added to a list of extension names that
        will be returned.

        .. note::

            By default, any exceptions found while loading will not be raised but will be printed to console (standard error/:data:`~sys.stderr`).

        .. versionadded:: 2.1

        Parameters
        ----------
        source_module: :class:`str`
            The name of the source module to look for submodules.
        ignore: Optional[List[:class:`str`]]
            File names of extensions to ignore.
        stop_at_error: :class:`bool`
            Whether or not an exception should be raised if we encounter one. Set to ``False`` by
            default.

        Returns
        -------
        List[:class:`str`]
            A list that contains the names of all of the extensions
            that loaded successfully.

        Raises
        ------
        ValueError
            The module at ``source_module`` is not found, or the module at ``source_module``
            has no submodules.
        ExtensionNotFound
            An extension could not be imported.
        ExtensionAlreadyLoaded
            An extension is already loaded.
        NoEntryPointError
            An extension does not have a setup function.
        ExtensionFailed
            An extension or its setup function had an execution error.
        """
        ...
    
    @property
    def extensions(self) -> Mapping[str, types.ModuleType]:
        """Mapping[:class:`str`, :class:`py:types.ModuleType`]: A read-only mapping of extension name to extension."""
        ...
    
    @property
    def help_command(self) -> Optional[HelpCommand]:
        ...
    
    @help_command.setter
    def help_command(self, value: Optional[HelpCommand]) -> None:
        ...
    
    async def get_prefix(self, message: Message) -> Union[List[str], str]:
        """|coro|

        Retrieves the prefix the bot is listening to
        with the message as a context.

        Parameters
        ----------
        message: :class:`nextcord.Message`
            The message context to get the prefix of.

        Returns
        -------
        Union[List[:class:`str`], :class:`str`]
            A list of prefixes or a single prefix that the bot is
            listening for.
        """
        ...
    
    async def get_context(self, message: Message, *, cls: Type[CXT] = ...) -> CXT:
        r"""|coro|

        Returns the invocation context from the message.

        This is a more low-level counter-part for :meth:`.process_commands`
        to allow users more fine grained control over the processing.

        The returned context is not guaranteed to be a valid invocation
        context, :attr:`.Context.valid` must be checked to make sure it is.
        If the context is not valid then it is not a valid candidate to be
        invoked under :meth:`~.Bot.invoke`.

        Parameters
        ----------
        message: :class:`nextcord.Message`
            The message to get the invocation context from.
        cls
            The factory class that will be used to create the context.
            By default, this is :class:`.Context`. Should a custom
            class be provided, it must be similar enough to :class:`.Context`\'s
            interface.

        Returns
        -------
        :class:`.Context`
            The invocation context. The type of this can change via the
            ``cls`` parameter.
        """
        ...
    
    async def invoke(self, ctx: Context) -> None:
        """|coro|

        Invokes the command given under the invocation context and
        handles all the internal event dispatch mechanisms.

        Parameters
        ----------
        ctx: :class:`.Context`
            The invocation context to invoke.
        """
        ...
    
    async def process_commands(self, message: Message) -> None:
        """|coro|

        This function processes the commands that have been registered
        to the bot and other groups. Without this coroutine, none of the
        commands will be triggered.

        By default, this coroutine is called inside the :func:`.on_message`
        event. If you choose to override the :func:`.on_message` event, then
        you should invoke this coroutine as well.

        This is built using other low level tools, and is equivalent to a
        call to :meth:`~.Bot.get_context` followed by a call to :meth:`~.Bot.invoke`.

        This also checks if the message's author is a bot and doesn't
        call :meth:`~.Bot.get_context` or :meth:`~.Bot.invoke` if so.

        Parameters
        ----------
        message: :class:`nextcord.Message`
            The message to process commands for.
        """
        ...
    
    async def process_with_str(self, message: Message, content: str) -> None:
        """|coro|

        This function is like :meth:`.process_commands` except it
        processes the provided message with different content.

        This is useful if you want to execute multiple commands in
        a single message.

        Example
        -------

        .. code-block:: python3

            @bot.event
            async def on_message(message):
                for msg in message.content.split(";"):
                    await bot.process_with_str(message, msg)

        Parameters
        ----------
        message: :class:`nextcord.Message`
            The message to process commands for.
        content: :class:`str`
            The content to subsitute for the message's content.
        """
        ...
    
    async def on_message(self, message) -> None:
        ...
    
    def add_application_command_check(self, func: ApplicationCheck) -> None:
        """Adds a global application check to the bot.

        This is the non-decorator interface to :meth:`.check`
        and :meth:`.check_once`.

        Parameters
        ----------
        func: Callable[[:class:`Interaction`], MaybeCoro[bool]]]
            The function that was used as a global application check.
        """
        ...
    
    def remove_application_command_check(self, func: ApplicationCheck) -> None:
        """Removes a global check from the bot.

        This function is idempotent and will not raise an exception
        if the function is not in the global checks.

        Parameters
        ----------
        func: Callable[[:class:`Interaction`], MaybeCoro[bool]]]
            The function to remove from the global application checks.
        """
        ...
    
    def application_command_check(self, func: Callable) -> ApplicationCheck:
        r"""A decorator that adds a global application check to the bot.

        A global check is similar to a :func:`.check` that is applied
        on a per command basis except it is run before any command checks
        have been verified and applies to every command the bot has.

        .. note::

            This function can either be a regular function or a coroutine.

        Similar to a command :func:`.check`\, this takes a single parameter
        of type :class:`.Interaction` and can only raise exceptions inherited from
        :exc:`.ApplicationError`.

        Example
        -------

        .. code-block:: python3

            @client.check
            def check_commands(interaction: Interaction) -> bool:
                return interaction.application_command.qualified_name in allowed_commands

        """
        ...
    
    def application_command_before_invoke(self, coro: ApplicationHook) -> ApplicationHook:
        """A decorator that registers a coroutine as a pre-invoke hook.

        A pre-invoke hook is called directly before the command is
        called. This makes it a useful function to set up database
        connections or any type of set up required.

        This pre-invoke hook takes a sole parameter, a :class:`.Interaction`.

        .. note::

            The :meth:`.application_command_before_invoke` and :meth:`.application_command_after_invoke`
            hooks are only called if all checks pass without error. If any check fails, then the hooks
            are not called.

        Parameters
        ----------
        coro: :ref:`coroutine <coroutine>`
            The coroutine to register as the pre-invoke hook.

        Raises
        ------
        TypeError
            The coroutine passed is not actually a coroutine.
        """
        ...
    
    def application_command_after_invoke(self, coro: ApplicationHook) -> ApplicationHook:
        r"""A decorator that registers a coroutine as a post-invoke hook.

        A post-invoke hook is called directly after the command is
        called. This makes it a useful function to clean-up database
        connections or any type of clean up required. There may only be
        one global post-invoke hook.

        This post-invoke hook takes a sole parameter, a :class:`.Interaction`.

        .. note::

            Similar to :meth:`~.Client.application_command_before_invoke`\, this is not called unless
            checks succeed. This hook is, however, **always** called regardless of the internal command
            callback raising an error (i.e. :exc:`.ApplicationInvokeError`\).
            This makes it ideal for clean-up scenarios.

        Parameters
        ----------
        coro: :ref:`coroutine`
            The coroutine to register as the post-invoke hook.

        Raises
        ------
        TypeError
            The coroutine passed is not actually a coroutine.
        """
        ...
    


class Bot(BotBase, nextcord.Client):
    """Represents a discord bot.

    This class is a subclass of :class:`nextcord.Client` and as a result
    anything that you can do with a :class:`nextcord.Client` you can do with
    this bot.

    This class also subclasses :class:`.GroupMixin` to provide the functionality
    to manage commands.

    Attributes
    ----------
    command_prefix
        The command prefix is what the message content must contain initially
        to have a command invoked. This prefix could either be a string to
        indicate what the prefix should be, or a callable that takes in the bot
        as its first parameter and :class:`nextcord.Message` as its second
        parameter and returns the prefix. This is to facilitate "dynamic"
        command prefixes. This callable can be either a regular function or
        a coroutine.

        An empty string as the prefix always matches, enabling prefix-less
        command invocation. While this may be useful in DMs it should be avoided
        in servers, as it's likely to cause performance issues and unintended
        command invocations.

        The command prefix could also be an iterable of strings indicating that
        multiple checks for the prefix should be used and the first one to
        match will be the invocation prefix. You can get this prefix via
        :attr:`.Context.prefix`.

        .. note::

            When passing multiple prefixes be careful to not pass a prefix
            that matches a longer prefix occurring later in the sequence.  For
            example, if the command prefix is ``('!', '!?')``  the ``'!?'``
            prefix will never be matched to any message as the previous one
            matches messages starting with ``!?``. This is especially important
            when passing an empty string, it should always be last as no prefix
            after it will be matched.
    case_insensitive: :class:`bool`
        Whether the commands should be case insensitive. Defaults to ``False``. This
        attribute does not carry over to groups. You must set it to every group if
        you require group commands to be case insensitive as well.
    description: :class:`str`
        The content prefixed into the default help message.
    help_command: Optional[:class:`.HelpCommand`]
        The help command implementation to use. This can be dynamically
        set at runtime. To remove the help command pass ``None``. For more
        information on implementing a help command, see :ref:`ext_commands_help_command`.
    owner_id: Optional[:class:`int`]
        The user ID that owns the bot. If this is not set and is then queried via
        :meth:`.is_owner` then it is fetched automatically using
        :meth:`~.Bot.application_info`.
    owner_ids: Optional[Collection[:class:`int`]]
        The user IDs that owns the bot. This is similar to :attr:`owner_id`.
        If this is not set and the application is team based, then it is
        fetched automatically using :meth:`~.Bot.application_info`.
        For performance reasons it is recommended to use a :class:`set`
        for the collection. You cannot set both ``owner_id`` and ``owner_ids``.

        .. versionadded:: 1.3
    strip_after_prefix: :class:`bool`
        Whether to strip whitespace characters after encountering the command
        prefix. This allows for ``!   hello`` and ``!hello`` to both work if
        the ``command_prefix`` is set to ``!``. Defaults to ``False``.

        .. versionadded:: 1.7
    """
    def __init__(self, command_prefix: Union[_NonCallablePrefix, Callable[[Union[Bot, AutoShardedBot], Message], Union[Awaitable[_NonCallablePrefix], _NonCallablePrefix],],] = ..., help_command: Optional[HelpCommand] = ..., description: Optional[str] = ..., *, max_messages: Optional[int] = ..., connector: Optional[aiohttp.BaseConnector] = ..., proxy: Optional[str] = ..., proxy_auth: Optional[aiohttp.BasicAuth] = ..., shard_id: Optional[int] = ..., shard_count: Optional[int] = ..., application_id: Optional[int] = ..., intents: nextcord.Intents = ..., member_cache_flags: MemberCacheFlags = ..., chunk_guilds_at_startup: bool = ..., status: Optional[Status] = ..., activity: Optional[BaseActivity] = ..., allowed_mentions: Optional[AllowedMentions] = ..., heartbeat_timeout: float = ..., guild_ready_timeout: float = ..., assume_unsync_clock: bool = ..., enable_debug_events: bool = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., lazy_load_commands: bool = ..., rollout_associate_known: bool = ..., rollout_delete_unknown: bool = ..., rollout_register_new: bool = ..., rollout_update_known: bool = ..., rollout_all_guilds: bool = ..., default_guild_ids: Optional[List[int]] = ..., owner_id: Optional[int] = ..., owner_ids: Optional[Iterable[int]] = ..., strip_after_prefix: bool = ..., case_insensitive: bool = ...) -> None:
        ...
    


class AutoShardedBot(BotBase, nextcord.AutoShardedClient):
    """This is similar to :class:`.Bot` except that it is inherited from
    :class:`nextcord.AutoShardedClient` instead.
    """
    def __init__(self, command_prefix: Union[_NonCallablePrefix, Callable[[Union[Bot, AutoShardedBot], Message], Union[Awaitable[_NonCallablePrefix], _NonCallablePrefix],],] = ..., help_command: Optional[HelpCommand] = ..., description: Optional[str] = ..., *, max_messages: Optional[int] = ..., connector: Optional[aiohttp.BaseConnector] = ..., proxy: Optional[str] = ..., proxy_auth: Optional[aiohttp.BasicAuth] = ..., shard_id: Optional[int] = ..., shard_count: Optional[int] = ..., shard_ids: Optional[list[int]] = ..., application_id: Optional[int] = ..., intents: nextcord.Intents = ..., member_cache_flags: MemberCacheFlags = ..., chunk_guilds_at_startup: bool = ..., status: Optional[Status] = ..., activity: Optional[BaseActivity] = ..., allowed_mentions: Optional[AllowedMentions] = ..., heartbeat_timeout: float = ..., guild_ready_timeout: float = ..., assume_unsync_clock: bool = ..., enable_debug_events: bool = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., lazy_load_commands: bool = ..., rollout_associate_known: bool = ..., rollout_delete_unknown: bool = ..., rollout_register_new: bool = ..., rollout_update_known: bool = ..., rollout_all_guilds: bool = ..., default_guild_ids: Optional[List[int]] = ..., owner_id: Optional[int] = ..., owner_ids: Optional[Iterable[int]] = ..., strip_after_prefix: bool = ..., case_insensitive: bool = ...) -> None:
        ...
    


