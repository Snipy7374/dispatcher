"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Optional, TYPE_CHECKING, TypeVar
from nextcord.enums import IntEnum
from typing_extensions import Self
from ...message import Message

if TYPE_CHECKING:
    ...
__all__ = ("BucketType", "Cooldown", "CooldownMapping", "DynamicCooldownMapping", "MaxConcurrency")
C = TypeVar("C", bound="CooldownMapping")
class BucketType(IntEnum):
    default = ...
    user = ...
    guild = ...
    channel = ...
    member = ...
    category = ...
    role = ...
    def get_key(self, msg: Message) -> Any:
        ...
    
    def __call__(self, msg: Message) -> Any:
        ...
    


class Cooldown:
    """Represents a cooldown for a command.

    Attributes
    ----------
    rate: :class:`int`
        The total number of tokens available per :attr:`per` seconds.
    per: :class:`float`
        The length of the cooldown period in seconds.
    """
    __slots__ = ...
    def __init__(self, rate: float, per: float) -> None:
        ...
    
    def get_tokens(self, current: Optional[float] = ...) -> int:
        """Returns the number of available tokens before rate limiting is applied.

        Parameters
        ----------
        current: Optional[:class:`float`]
            The time in seconds since Unix epoch to calculate tokens at.
            If not supplied then :func:`time.time()` is used.

        Returns
        -------
        :class:`int`
            The number of tokens available before the cooldown is to be applied.
        """
        ...
    
    def get_retry_after(self, current: Optional[float] = ...) -> float:
        """Returns the time in seconds until the cooldown will be reset.

        Parameters
        ----------
        current: Optional[:class:`float`]
            The current time in seconds since Unix epoch.
            If not supplied, then :func:`time.time()` is used.

        Returns
        -------
        :class:`float`
            The number of seconds to wait before this cooldown will be reset.
        """
        ...
    
    def update_rate_limit(self, current: Optional[float] = ...) -> Optional[float]:
        """Updates the cooldown rate limit.

        Parameters
        ----------
        current: Optional[:class:`float`]
            The time in seconds since Unix epoch to update the rate limit at.
            If not supplied, then :func:`time.time()` is used.

        Returns
        -------
        Optional[:class:`float`]
            The retry-after time in seconds if rate limited.
        """
        ...
    
    def reset(self) -> None:
        """Reset the cooldown to its initial state."""
        ...
    
    def copy(self) -> Cooldown:
        """Creates a copy of this cooldown.

        Returns
        -------
        :class:`Cooldown`
            A new instance of this cooldown.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


class CooldownMapping:
    def __init__(self, original: Optional[Cooldown], type: Callable[[Message], Any]) -> None:
        ...
    
    def copy(self) -> CooldownMapping:
        ...
    
    @property
    def valid(self) -> bool:
        ...
    
    @property
    def type(self) -> Callable[[Message], Any]:
        ...
    
    @classmethod
    def from_cooldown(cls, rate, per, type) -> Self:
        ...
    
    def create_bucket(self, message: Message) -> Cooldown:
        ...
    
    def get_bucket(self, message: Message, current: Optional[float] = ...) -> Cooldown:
        ...
    
    def update_rate_limit(self, message: Message, current: Optional[float] = ...) -> Optional[float]:
        ...
    


class DynamicCooldownMapping(CooldownMapping):
    def __init__(self, factory: Callable[[Message], Cooldown], type: Callable[[Message], Any]) -> None:
        ...
    
    def copy(self) -> DynamicCooldownMapping:
        ...
    
    @property
    def valid(self) -> bool:
        ...
    
    def create_bucket(self, message: Message) -> Cooldown:
        ...
    


class _Semaphore:
    """This class is a version of a semaphore.

    If you're wondering why asyncio.Semaphore isn't being used,
    it's because it doesn't expose the internal value. This internal
    value is necessary because I need to support both `wait=True` and
    `wait=False`.

    An asyncio.Queue could have been used to do this as well -- but it is
    not as inefficient since internally that uses two queues and is a bit
    overkill for what is basically a counter.
    """
    __slots__ = ...
    def __init__(self, number: int) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def locked(self) -> bool:
        ...
    
    def is_active(self) -> bool:
        ...
    
    def wake_up(self) -> None:
        ...
    
    async def acquire(self, *, wait: bool = ...) -> bool:
        ...
    
    def release(self) -> None:
        ...
    


class MaxConcurrency:
    __slots__ = ...
    def __init__(self, number: int, *, per: BucketType, wait: bool) -> None:
        ...
    
    def copy(self) -> Self:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def get_key(self, message: Message) -> Any:
        ...
    
    async def acquire(self, message: Message) -> None:
        ...
    
    async def release(self, message: Message) -> None:
        ...
    


