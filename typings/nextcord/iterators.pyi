"""
This type stub file was generated by pyright.
"""

import datetime
from typing import Any, AsyncIterator, Awaitable, Callable, Generic, List, Optional, TYPE_CHECKING, TypeVar, Union
from .audit_logs import AuditLogEntry
from .bans import BanEntry
from .abc import Messageable, Snowflake, SnowflakeTime
from .client import Client
from .enums import AuditLogAction
from .guild import Guild
from .member import Member
from .message import Message
from .scheduled_events import ScheduledEvent, ScheduledEventUser
from .threads import Thread
from .types.guild import Guild as GuildPayload
from .types.member import MemberWithUser
from .types.scheduled_events import ScheduledEvent as ScheduledEventPayload, ScheduledEventUser as ScheduledEventUserPayload
from .types.threads import Thread as ThreadPayload
from .user import User

__all__ = ("ReactionIterator", "HistoryIterator", "BanIterator", "AuditLogIterator", "GuildIterator", "MemberIterator", "ScheduledEventIterator", "ScheduledEventUserIterator")
if TYPE_CHECKING:
    ...
T = TypeVar("T")
OT = TypeVar("OT")
_Func = Callable[[T], Union[OT, Awaitable[OT]]]
OLDEST_OBJECT = ...
class _AsyncIterator(AsyncIterator[T]):
    __slots__ = ...
    async def next(self) -> T:
        ...
    
    def get(self, **attrs: T) -> Awaitable[Optional[T]]:
        ...
    
    async def find(self, predicate: _Func[T, bool]) -> Optional[T]:
        ...
    
    def chunk(self, max_size: int) -> _ChunkedAsyncIterator[T]:
        ...
    
    def map(self, func: _Func[T, OT]) -> _MappedAsyncIterator[T, OT]:
        ...
    
    def filter(self, predicate: _Func[T, bool]) -> _FilteredAsyncIterator[T]:
        ...
    
    async def flatten(self) -> List[T]:
        ...
    
    async def __anext__(self) -> T:
        ...
    


class _ChunkedAsyncIterator(_AsyncIterator[List[T]]):
    def __init__(self, iterator: _AsyncIterator[T], max_size: int) -> None:
        ...
    
    async def next(self) -> List[T]:
        ...
    


class _MappedAsyncIterator(_AsyncIterator[OT], Generic[T, OT]):
    def __init__(self, iterator: _AsyncIterator[T], func: _Func[T, OT]) -> None:
        ...
    
    async def next(self) -> OT:
        ...
    


class _FilteredAsyncIterator(_AsyncIterator[T]):
    def __init__(self, iterator: _AsyncIterator[T], predicate: _Func[T, Any]) -> None:
        ...
    
    async def next(self) -> T:
        ...
    


class ReactionIterator(_AsyncIterator[Union["User", "Member"]]):
    def __init__(self, message: Message, emoji: str, limit: int = ..., after: Optional[Snowflake] = ...) -> None:
        ...
    
    async def next(self) -> Union[User, Member]:
        ...
    
    async def fill_users(self) -> None:
        ...
    


class HistoryIterator(_AsyncIterator["Message"]):
    """Iterator for receiving a channel's message history.

    The messages endpoint has two behaviours we care about here:
    If ``before`` is specified, the messages endpoint returns the ``limit``
    newest messages before ``before``, sorted with newest first. For filling over
    100 messages, update the ``before`` parameter to the oldest message received.
    Messages will be returned in order by time.
    If ``after`` is specified, it returns the ``limit`` oldest messages after
    ``after``, sorted with newest first. For filling over 100 messages, update the
    ``after`` parameter to the newest message received. If messages are not
    reversed, they will be out of order (99-0, 199-100, so on)

    A note that if both ``before`` and ``after`` are specified, ``before`` is ignored by the
    messages endpoint.

    Parameters
    ----------
    messageable: :class:`abc.Messageable`
        Messageable class to retrieve message history from.
    limit: :class:`int`
        Maximum number of messages to retrieve
    before: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
        Message before which all messages must be.
    after: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
        Message after which all messages must be.
    around: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
        Message around which all messages must be. Limit max 101. Note that if
        limit is an even number, this will return at most limit+1 messages.
    oldest_first: Optional[:class:`bool`]
        If set to ``True``, return messages in oldest->newest order. Defaults to
        ``True`` if ``after`` is specified, otherwise ``False``.
    """
    def __init__(self, messageable: Messageable, limit: Optional[int], before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ..., around: Optional[SnowflakeTime] = ..., oldest_first: Optional[bool] = ...) -> None:
        ...
    
    async def next(self) -> Message:
        ...
    
    async def fill_messages(self) -> None:
        ...
    


class BanIterator(_AsyncIterator["BanEntry"]):
    """Iterator for receiving a guild's bans.

    The bans endpoint has two behaviours we care about here:
    If ``before`` is specified, the bans endpoint returns the ``limit``
    bans with user ids before ``before``, sorted with smallest first. For filling over
    1000 bans, update the ``before`` parameter to the largest user id received.
    If ``after`` is specified, it returns the ``limit`` bans with user ids after
    ``after``, sorted with smallest first. For filling over 1000 bans, update the
    ``after`` parameter to the smallest user id received.

    A note that if both ``before`` and ``after`` are specified, ``after`` is ignored by the
    bans endpoint.

    Parameters
    ----------
    guild: :class:`~nextcord.Guild`
        The guild to get bans from.
    limit: Optional[:class:`int`]
        Maximum number of bans to retrieve.
    before: Optional[:class:`abc.Snowflake`]
        Date or user id before which all bans must be.
    after: Optional[:class:`abc.Snowflake`]
        Date or user id after which all bans must be.
    """
    def __init__(self, guild: Guild, limit: Optional[int] = ..., before: Optional[Snowflake] = ..., after: Optional[Snowflake] = ...) -> None:
        ...
    
    async def next(self) -> BanEntry:
        ...
    
    async def fill_bans(self) -> None:
        ...
    


class AuditLogIterator(_AsyncIterator["AuditLogEntry"]):
    def __init__(self, guild: Guild, limit: Optional[int] = ..., before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ..., oldest_first: Optional[bool] = ..., user_id: Optional[int] = ..., action_type: Optional[AuditLogAction] = ...) -> None:
        ...
    
    async def next(self) -> AuditLogEntry:
        ...
    


class GuildIterator(_AsyncIterator["Guild"]):
    """Iterator for receiving the client's guilds.

    The guilds endpoint has the same two behaviours as described
    in :class:`HistoryIterator`:
    If ``before`` is specified, the guilds endpoint returns the ``limit``
    newest guilds before ``before``, sorted with newest first. For filling over
    100 guilds, update the ``before`` parameter to the oldest guild received.
    Guilds will be returned in order by time.
    If ``after`` is specified, it returns the ``limit`` oldest guilds after ``after``,
    sorted with newest first. For filling over 100 guilds, update the ``after``
    parameter to the newest guild received, If guilds are not reversed, they
    will be out of order (99-0, 199-100, so on)

    Not that if both ``before`` and ``after`` are specified, ``before`` is ignored by the
    guilds endpoint.

    Parameters
    ----------
    bot: :class:`nextcord.Client`
        The client to retrieve the guilds from.
    limit: :class:`int`
        Maximum number of guilds to retrieve.
    before: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
        Object before which all guilds must be.
    after: Optional[Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]]
        Object after which all guilds must be.
    """
    def __init__(self, bot: Client, limit: Optional[int], before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ...) -> None:
        ...
    
    async def next(self) -> Guild:
        ...
    
    def create_guild(self, data: GuildPayload) -> Guild:
        ...
    
    async def fill_guilds(self) -> None:
        ...
    


class MemberIterator(_AsyncIterator["Member"]):
    def __init__(self, guild: Guild, limit: Optional[int] = ..., after: Optional[Union[Snowflake, datetime.datetime]] = ...) -> None:
        ...
    
    async def next(self) -> Member:
        ...
    
    async def fill_members(self) -> None:
        ...
    
    def create_member(self, data: MemberWithUser) -> Member:
        ...
    


class ArchivedThreadIterator(_AsyncIterator["Thread"]):
    def __init__(self, channel_id: int, guild: Guild, limit: Optional[int], joined: bool, private: bool, before: Optional[Union[Snowflake, datetime.datetime]] = ...) -> None:
        ...
    
    async def next(self) -> Thread:
        ...
    
    @staticmethod
    def get_archive_timestamp(data: ThreadPayload) -> str:
        ...
    
    @staticmethod
    def get_thread_id(data: ThreadPayload) -> str:
        ...
    
    async def fill_queue(self) -> None:
        ...
    
    def create_thread(self, data: ThreadPayload) -> Thread:
        ...
    


class ScheduledEventIterator(_AsyncIterator["ScheduledEvent"]):
    def __init__(self, guild: Guild, with_users: bool = ...) -> None:
        ...
    
    async def next(self) -> ScheduledEvent:
        ...
    
    async def fill_queue(self) -> None:
        ...
    
    def create_event(self, data: ScheduledEventPayload) -> ScheduledEvent:
        ...
    


class ScheduledEventUserIterator(_AsyncIterator["ScheduledEventUser"]):
    def __init__(self, guild: Guild, event: ScheduledEvent, with_member: bool = ..., limit: Optional[int] = ..., before: Optional[Snowflake] = ..., after: Optional[Snowflake] = ...) -> None:
        ...
    
    async def next(self) -> ScheduledEventUser:
        ...
    
    async def fill_queue(self) -> None:
        ...
    
    def create_user(self, data: ScheduledEventUserPayload) -> ScheduledEventUser:
        ...
    


